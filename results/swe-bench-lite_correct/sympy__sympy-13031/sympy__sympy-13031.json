{
    "bug_id": "sympy__sympy-13031",
    "problem_statement": "Behavior of Matrix hstack and vstack changed in sympy 1.1\nIn sympy 1.0:\r\n```\r\nimport sympy as sy\r\nM1 = sy.Matrix.zeros(0, 0)\r\nM2 = sy.Matrix.zeros(0, 1)\r\nM3 = sy.Matrix.zeros(0, 2)\r\nM4 = sy.Matrix.zeros(0, 3)\r\nsy.Matrix.hstack(M1, M2, M3, M4).shape\r\n```\r\nreturns \r\n`(0, 6)`\r\n\r\nNow, same in sympy 1.1:\r\n```\r\nimport sympy as sy\r\nM1 = sy.Matrix.zeros(0, 0)\r\nM2 = sy.Matrix.zeros(0, 1)\r\nM3 = sy.Matrix.zeros(0, 2)\r\nM4 = sy.Matrix.zeros(0, 3)\r\nsy.Matrix.hstack(M1, M2, M3, M4).shape\r\n```\r\nreturns\r\n`(0, 3)\r\n`\r\nwhereas:\r\n```\r\nimport sympy as sy\r\nM1 = sy.Matrix.zeros(1, 0)\r\nM2 = sy.Matrix.zeros(1, 1)\r\nM3 = sy.Matrix.zeros(1, 2)\r\nM4 = sy.Matrix.zeros(1, 3)\r\nsy.Matrix.hstack(M1, M2, M3, M4).shape\r\n```\r\nreturns\r\n`(1, 6)\r\n`\n",
    "dev_patch": "diff --git a/sympy/matrices/sparse.py b/sympy/matrices/sparse.py\n--- a/sympy/matrices/sparse.py\n+++ b/sympy/matrices/sparse.py\n@@ -985,8 +985,10 @@ def col_join(self, other):\n         >>> C == A.row_insert(A.rows, Matrix(B))\n         True\n         \"\"\"\n-        if not self:\n-            return type(self)(other)\n+        # A null matrix can always be stacked (see  #10770)\n+        if self.rows == 0 and self.cols != other.cols:\n+            return self._new(0, other.cols, []).col_join(other)\n+\n         A, B = self, other\n         if not A.cols == B.cols:\n             raise ShapeError()\n@@ -1191,8 +1193,10 @@ def row_join(self, other):\n         >>> C == A.col_insert(A.cols, B)\n         True\n         \"\"\"\n-        if not self:\n-            return type(self)(other)\n+        # A null matrix can always be stacked (see  #10770)\n+        if self.cols == 0 and self.rows != other.rows:\n+            return self._new(other.rows, 0, []).row_join(other)\n+\n         A, B = self, other\n         if not A.rows == B.rows:\n             raise ShapeError()\n",
    "our_patch": "diff --git a/sympy/matrices/sparse.py b/sympy/matrices/sparse.py\n--- a/sympy/matrices/sparse.py\n+++ b/sympy/matrices/sparse.py\n@@ -985,8 +985,12 @@\n         >>> C == A.row_insert(A.rows, Matrix(B))\n         True\n         \"\"\"\n-        if not self:\n+        # Handle the case where one of the matrices is zero-sized\n+        if self.rows == 0:\n             return type(self)(other)\n+        if other.rows == 0:\n+            return self.copy()\n+\n         A, B = self, other\n         if not A.cols == B.cols:\n             raise ShapeError()\n@@ -1005,6 +1009,7 @@\n                 A._smat[i + A.rows, j] = v\n         A.rows += B.rows\n         return A\n+\n \n     def col_op(self, j, f):\n         \"\"\"In-place operation on col j using two-arg functor whose args are\n@@ -1191,8 +1196,12 @@\n         >>> C == A.col_insert(A.cols, B)\n         True\n         \"\"\"\n-        if not self:\n+        # Handle the case where one of the matrices is zero-sized\n+        if self.cols == 0:\n             return type(self)(other)\n+        if other.cols == 0:\n+            return self.copy()\n+\n         A, B = self, other\n         if not A.rows == B.rows:\n             raise ShapeError()\n@@ -1212,6 +1221,7 @@\n         A.cols += B.cols\n         return A\n \n+\n     def row_op(self, i, f):\n         \"\"\"In-place operation on row ``i`` using two-arg functor whose args are\n         interpreted as ``(self[i, j], j)``.\n",
    "final_iteration": 2,
    "buggy_methods": [
        "sympy/matrices/sparse.py::col_join",
        "sympy/matrices/sparse.py::row_join"
    ],
    "num_buggy_methods": 2
}