{
    "bug_id": "django__django-11999",
    "problem_statement": "Cannot override get_FOO_display() in Django 2.2+.\nDescription\n\t\nI cannot override the get_FIELD_display function on models since version 2.2. It works in version 2.1.\nExample:\nclass FooBar(models.Model):\n\tfoo_bar = models.CharField(_(\"foo\"), choices=[(1, 'foo'), (2, 'bar')])\n\tdef __str__(self):\n\t\treturn self.get_foo_bar_display() # This returns 'foo' or 'bar' in 2.2, but 'something' in 2.1\n\tdef get_foo_bar_display(self):\n\t\treturn \"something\"\nWhat I expect is that I should be able to override this function.\n",
    "dev_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,8 +763,12 @@ def contribute_to_class(self, cls, name, private_only=False):\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n         if self.choices is not None:\n-            setattr(cls, 'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self))\n+            if not hasattr(cls, 'get_%s_display' % self.name):\n+                setattr(\n+                    cls,\n+                    'get_%s_display' % self.name,\n+                    partialmethod(cls._get_FIELD_display, field=self),\n+                )\n \n     def get_filter_kwargs_for_object(self, obj):\n         \"\"\"\n",
    "our_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,8 +763,9 @@\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n         if self.choices is not None:\n-            setattr(cls, 'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self))\n+            display_method_name = 'get_%s_display' % self.name\n+            if not hasattr(cls, display_method_name):\n+                setattr(cls, display_method_name, partialmethod(cls._get_FIELD_display, field=self))\n \n     def get_filter_kwargs_for_object(self, obj):\n         \"\"\"\n@@ -1186,17 +1187,26 @@\n         else:\n             return super().pre_save(model_instance, add)\n \n-    def contribute_to_class(self, cls, name, **kwargs):\n-        super().contribute_to_class(cls, name, **kwargs)\n-        if not self.null:\n-            setattr(\n-                cls, 'get_next_by_%s' % self.name,\n-                partialmethod(cls._get_next_or_previous_by_FIELD, field=self, is_next=True)\n-            )\n-            setattr(\n-                cls, 'get_previous_by_%s' % self.name,\n-                partialmethod(cls._get_next_or_previous_by_FIELD, field=self, is_next=False)\n-            )\n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.column:\n+            # Don't override classmethods with the descriptor. This means that\n+            # if you have a classmethod and a field with the same name, then\n+            # such fields can't be deferred (we don't have a check for this).\n+            if not getattr(cls, self.attname, None):\n+                setattr(cls, self.attname, self.descriptor_class(self))\n+        if self.choices is not None:\n+            display_method_name = 'get_%s_display' % self.name\n+            if not hasattr(cls, display_method_name):\n+                setattr(cls, display_method_name, partialmethod(cls._get_FIELD_display, field=self))\n \n     def get_prep_value(self, value):\n         value = super().get_prep_value(value)\n@@ -2354,13 +2364,26 @@\n             value = connection.ops.validate_autopk_value(value)\n         return value\n \n-    def contribute_to_class(self, cls, name, **kwargs):\n-        assert not cls._meta.auto_field, (\n-            \"Model %s can't have more than one auto-generated field.\"\n-            % cls._meta.label\n-        )\n-        super().contribute_to_class(cls, name, **kwargs)\n-        cls._meta.auto_field = self\n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.column:\n+            # Don't override classmethods with the descriptor. This means that\n+            # if you have a classmethod and a field with the same name, then\n+            # such fields can't be deferred (we don't have a check for this).\n+            if not getattr(cls, self.attname, None):\n+                setattr(cls, self.attname, self.descriptor_class(self))\n+        if self.choices is not None:\n+            display_method_name = 'get_%s_display' % self.name\n+            if not hasattr(cls, display_method_name):\n+                setattr(cls, display_method_name, partialmethod(cls._get_FIELD_display, field=self))\n \n     def formfield(self, **kwargs):\n         return None\n",
    "final_iteration": 1,
    "buggy_methods": [
        "django/db/models/fields/__init__.py::contribute_to_class"
    ],
    "num_buggy_methods": 1
}