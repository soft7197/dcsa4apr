{
    "bug_id": "JacksonCore-19",
    "success": true,
    "error": null,
    "patch": null,
    "project_path": "/tmp/d4j_JacksonCore-19_1757272600",
    "patches": [
        {
            "hypothesis": "The bug occurs due to a failure to handle input buffer boundaries properly, causing an ArrayIndexOutOfBoundsException when the input is exactly at, or exceeds, the buffer length. This is especially problematic for the case of long sequences of numbers as seen in the failing test case. When the buffer is exhausted and 'loadMore()' is called to fetch more data into '_inputBuffer', the segment completion using '_textBuffer.finishCurrentSegment()' resets 'outPtr' to zero for the continuation. If 'outPtr' is not reset properly, an overflow can occur when adding new characters into 'outBuf'. Additionally, there are missing checks for the size of 'outBuf' when appending to ensure there is always space available in the buffer before writing. Both methods should handle buffer exhaustion properly and also ensure that the outBuf has sufficient capacity for the next character to be written.",
            "methods": [
                {
                    "method_name": "_parseNumber2",
                    "fixed_method": "private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n\n    // Need to prepend sign?\n    if (neg) {\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = '-';\n    }\n\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n\n    // Ok, first the obligatory integer part:\n    int_loop:\n    while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') { // yes, fraction\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n\n        fract_loop:\n        while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n\n    int expLen = 0;\n    if (c == 'e' || c == 'E') { // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n        }\n\n        exp_loop:\n        while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}",
                    "diff": "--- original\n+++ fixed\n@@ -1,130 +1,129 @@\n-    /**\n-     * Method called to parse a number, when the primary parse\n-     * method has failed to parse it, due to it being split on\n-     * buffer boundary. As a result code is very similar, except\n-     * that it has to explicitly copy contents to the text buffer\n-     * instead of just sharing the main input buffer.\n-     */\n+private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n+    _inputPtr = neg ? (startPtr + 1) : startPtr;\n+    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n+    int outPtr = 0;\n \n-    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n-    {\n-        _inputPtr = neg ? (startPtr+1) : startPtr;\n-        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n-        int outPtr = 0;\n+    // Need to prepend sign?\n+    if (neg) {\n+        if (outPtr >= outBuf.length) {\n+            outBuf = _textBuffer.finishCurrentSegment();\n+            outPtr = 0;\n+        }\n+        outBuf[outPtr++] = '-';\n+    }\n \n-        // Need to prepend sign?\n-        if (neg) {\n-            outBuf[outPtr++] = '-';\n+    // This is the place to do leading-zero check(s) too:\n+    int intLen = 0;\n+    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n+    if (c == '0') {\n+        c = _verifyNoLeadingZeroes();\n+    }\n+    boolean eof = false;\n+\n+    // Ok, first the obligatory integer part:\n+    int_loop:\n+    while (c >= '0' && c <= '9') {\n+        ++intLen;\n+        if (outPtr >= outBuf.length) {\n+            outBuf = _textBuffer.finishCurrentSegment();\n+            outPtr = 0;\n+        }\n+        outBuf[outPtr++] = c;\n+        if (_inputPtr >= _inputEnd && !loadMore()) {\n+            // EOF is legal for main level int values\n+            c = CHAR_NULL;\n+            eof = true;\n+            break int_loop;\n+        }\n+        c = _inputBuffer[_inputPtr++];\n+    }\n+    // Also, integer part is not optional\n+    if (intLen == 0) {\n+        return _handleInvalidNumberStart(c, neg);\n+    }\n+\n+    int fractLen = 0;\n+    // And then see if we get other parts\n+    if (c == '.') { // yes, fraction\n+        if (outPtr >= outBuf.length) {\n+            outBuf = _textBuffer.finishCurrentSegment();\n+            outPtr = 0;\n+        }\n+        outBuf[outPtr++] = c;\n+\n+        fract_loop:\n+        while (true) {\n+            if (_inputPtr >= _inputEnd && !loadMore()) {\n+                eof = true;\n+                break fract_loop;\n+            }\n+            c = _inputBuffer[_inputPtr++];\n+            if (c < INT_0 || c > INT_9) {\n+                break fract_loop;\n+            }\n+            ++fractLen;\n+            if (outPtr >= outBuf.length) {\n+                outBuf = _textBuffer.finishCurrentSegment();\n+                outPtr = 0;\n+            }\n+            outBuf[outPtr++] = c;\n+        }\n+        // must be followed by sequence of ints, one minimum\n+        if (fractLen == 0) {\n+            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n+        }\n+    }\n+\n+    int expLen = 0;\n+    if (c == 'e' || c == 'E') { // exponent?\n+        if (outPtr >= outBuf.length) {\n+            outBuf = _textBuffer.finishCurrentSegment();\n+            outPtr = 0;\n+        }\n+        outBuf[outPtr++] = c;\n+        // Not optional, can require that we get one more char\n+        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n+                : getNextChar(\"expected a digit for number exponent\");\n+        // Sign indicator?\n+        if (c == '-' || c == '+') {\n+            if (outPtr >= outBuf.length) {\n+                outBuf = _textBuffer.finishCurrentSegment();\n+                outPtr = 0;\n+            }\n+            outBuf[outPtr++] = c;\n+            // Likewise, non optional:\n+            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n+                    : getNextChar(\"expected a digit for number exponent\");\n         }\n \n-        // This is the place to do leading-zero check(s) too:\n-        int intLen = 0;\n-        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n-        if (c == '0') {\n-            c = _verifyNoLeadingZeroes();\n-        }\n-        boolean eof = false;\n-\n-        // Ok, first the obligatory integer part:\n-        int_loop:\n-        while (c >= '0' && c <= '9') {\n-            ++intLen;\n+        exp_loop:\n+        while (c <= INT_9 && c >= INT_0) {\n+            ++expLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n                 outPtr = 0;\n             }\n             outBuf[outPtr++] = c;\n             if (_inputPtr >= _inputEnd && !loadMore()) {\n-                // EOF is legal for main level int values\n-                c = CHAR_NULL;\n                 eof = true;\n-                break int_loop;\n+                break exp_loop;\n             }\n             c = _inputBuffer[_inputPtr++];\n         }\n-        // Also, integer part is not optional\n-        if (intLen == 0) {\n-            return _handleInvalidNumberStart(c, neg);\n+        // must be followed by sequence of ints, one minimum\n+        if (expLen == 0) {\n+            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n         }\n+    }\n \n-        int fractLen = 0;\n-        // And then see if we get other parts\n-        if (c == '.') { // yes, fraction\n-            outBuf[outPtr++] = c;\n-\n-            fract_loop:\n-            while (true) {\n-                if (_inputPtr >= _inputEnd && !loadMore()) {\n-                    eof = true;\n-                    break fract_loop;\n-                }\n-                c = _inputBuffer[_inputPtr++];\n-                if (c < INT_0 || c > INT_9) {\n-                    break fract_loop;\n-                }\n-                ++fractLen;\n-                if (outPtr >= outBuf.length) {\n-                    outBuf = _textBuffer.finishCurrentSegment();\n-                    outPtr = 0;\n-                }\n-                outBuf[outPtr++] = c;\n-            }\n-            // must be followed by sequence of ints, one minimum\n-            if (fractLen == 0) {\n-                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n-            }\n+    // Ok; unless we hit end-of-input, need to push last char read back\n+    if (!eof) {\n+        --_inputPtr;\n+        if (_parsingContext.inRoot()) {\n+            _verifyRootSpace(c);\n         }\n-\n-        int expLen = 0;\n-        if (c == 'e' || c == 'E') { // exponent?\n-            if (outPtr >= outBuf.length) {\n-                outBuf = _textBuffer.finishCurrentSegment();\n-                outPtr = 0;\n-            }\n-            outBuf[outPtr++] = c;\n-            // Not optional, can require that we get one more char\n-            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n-                : getNextChar(\"expected a digit for number exponent\");\n-            // Sign indicator?\n-            if (c == '-' || c == '+') {\n-                if (outPtr >= outBuf.length) {\n-                    outBuf = _textBuffer.finishCurrentSegment();\n-                    outPtr = 0;\n-                }\n-                outBuf[outPtr++] = c;\n-                // Likewise, non optional:\n-                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n-                    : getNextChar(\"expected a digit for number exponent\");\n-            }\n-\n-            exp_loop:\n-            while (c <= INT_9 && c >= INT_0) {\n-                ++expLen;\n-                if (outPtr >= outBuf.length) {\n-                    outBuf = _textBuffer.finishCurrentSegment();\n-                    outPtr = 0;\n-                }\n-                outBuf[outPtr++] = c;\n-                if (_inputPtr >= _inputEnd && !loadMore()) {\n-                    eof = true;\n-                    break exp_loop;\n-                }\n-                c = _inputBuffer[_inputPtr++];\n-            }\n-            // must be followed by sequence of ints, one minimum\n-            if (expLen == 0) {\n-                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n-            }\n-        }\n-\n-        // Ok; unless we hit end-of-input, need to push last char read back\n-        if (!eof) {\n-            --_inputPtr;\n-            if (_parsingContext.inRoot()) {\n-                _verifyRootSpace(c);\n-            }\n-        }\n-        _textBuffer.setCurrentLength(outPtr);\n-        // And there we have it!\n-        return reset(neg, intLen, fractLen, expLen);\n     }\n+    _textBuffer.setCurrentLength(outPtr);\n+    // And there we have it!\n+    return reset(neg, intLen, fractLen, expLen);\n+}",
                    "line_numbers": [
                        1374,
                        1496
                    ],
                    "file_path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java"
                },
                {
                    "method_name": "_parseFloat",
                    "fixed_method": "private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n        boolean negative, int integerPartLength) throws IOException {\n    int fractLen = 0;\n    boolean eof = false;\n\n    // And then see if we get other parts\n    if (c == INT_PERIOD) { // yes, fraction\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n\n        fract_loop:\n        while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n\n    int expLen = 0;\n    if (c == INT_e || c == INT_E) { // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        exp_loop:\n        while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per [core#105], need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}",
                    "diff": "--- original\n+++ fixed\n@@ -1,93 +1,95 @@\n+private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n+        boolean negative, int integerPartLength) throws IOException {\n+    int fractLen = 0;\n+    boolean eof = false;\n \n-    private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n-            boolean negative, int integerPartLength) throws IOException\n-    {\n-        int fractLen = 0;\n-        boolean eof = false;\n+    // And then see if we get other parts\n+    if (c == INT_PERIOD) { // yes, fraction\n+        if (outPtr >= outBuf.length) {\n+            outBuf = _textBuffer.finishCurrentSegment();\n+            outPtr = 0;\n+        }\n+        outBuf[outPtr++] = (char) c;\n \n-        // And then see if we get other parts\n-        if (c == INT_PERIOD) { // yes, fraction\n-            outBuf[outPtr++] = (char) c;\n-\n-            fract_loop:\n-            while (true) {\n-                if (_inputPtr >= _inputEnd && !loadMore()) {\n-                    eof = true;\n-                    break fract_loop;\n-                }\n-                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n-                if (c < INT_0 || c > INT_9) {\n-                    break fract_loop;\n-                }\n-                ++fractLen;\n-                if (outPtr >= outBuf.length) {\n-                    outBuf = _textBuffer.finishCurrentSegment();\n-                    outPtr = 0;\n-                }\n-                outBuf[outPtr++] = (char) c;\n+        fract_loop:\n+        while (true) {\n+            if (_inputPtr >= _inputEnd && !loadMore()) {\n+                eof = true;\n+                break fract_loop;\n             }\n-            // must be followed by sequence of ints, one minimum\n-            if (fractLen == 0) {\n-                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n+            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n+            if (c < INT_0 || c > INT_9) {\n+                break fract_loop;\n             }\n-        }\n-\n-        int expLen = 0;\n-        if (c == INT_e || c == INT_E) { // exponent?\n+            ++fractLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n                 outPtr = 0;\n             }\n             outBuf[outPtr++] = (char) c;\n-            // Not optional, can require that we get one more char\n+        }\n+        // must be followed by sequence of ints, one minimum\n+        if (fractLen == 0) {\n+            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n+        }\n+    }\n+\n+    int expLen = 0;\n+    if (c == INT_e || c == INT_E) { // exponent?\n+        if (outPtr >= outBuf.length) {\n+            outBuf = _textBuffer.finishCurrentSegment();\n+            outPtr = 0;\n+        }\n+        outBuf[outPtr++] = (char) c;\n+        // Not optional, can require that we get one more char\n+        if (_inputPtr >= _inputEnd) {\n+            loadMoreGuaranteed();\n+        }\n+        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n+        // Sign indicator?\n+        if (c == '-' || c == '+') {\n+            if (outPtr >= outBuf.length) {\n+                outBuf = _textBuffer.finishCurrentSegment();\n+                outPtr = 0;\n+            }\n+            outBuf[outPtr++] = (char) c;\n+            // Likewise, non optional:\n             if (_inputPtr >= _inputEnd) {\n                 loadMoreGuaranteed();\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n-            // Sign indicator?\n-            if (c == '-' || c == '+') {\n-                if (outPtr >= outBuf.length) {\n-                    outBuf = _textBuffer.finishCurrentSegment();\n-                    outPtr = 0;\n-                }\n-                outBuf[outPtr++] = (char) c;\n-                // Likewise, non optional:\n-                if (_inputPtr >= _inputEnd) {\n-                    loadMoreGuaranteed();\n-                }\n-                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n-            }\n-\n-            exp_loop:\n-            while (c <= INT_9 && c >= INT_0) {\n-                ++expLen;\n-                if (outPtr >= outBuf.length) {\n-                    outBuf = _textBuffer.finishCurrentSegment();\n-                    outPtr = 0;\n-                }\n-                outBuf[outPtr++] = (char) c;\n-                if (_inputPtr >= _inputEnd && !loadMore()) {\n-                    eof = true;\n-                    break exp_loop;\n-                }\n-                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n-            }\n-            // must be followed by sequence of ints, one minimum\n-            if (expLen == 0) {\n-                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n-            }\n         }\n \n-        // Ok; unless we hit end-of-input, need to push last char read back\n-        if (!eof) {\n-            --_inputPtr;\n-            // As per [core#105], need separating space between root values; check here\n-            if (_parsingContext.inRoot()) {\n-                _verifyRootSpace(c);\n+        exp_loop:\n+        while (c <= INT_9 && c >= INT_0) {\n+            ++expLen;\n+            if (outPtr >= outBuf.length) {\n+                outBuf = _textBuffer.finishCurrentSegment();\n+                outPtr = 0;\n             }\n+            outBuf[outPtr++] = (char) c;\n+            if (_inputPtr >= _inputEnd && !loadMore()) {\n+                eof = true;\n+                break exp_loop;\n+            }\n+            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n-        _textBuffer.setCurrentLength(outPtr);\n+        // must be followed by sequence of ints, one minimum\n+        if (expLen == 0) {\n+            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n+        }\n+    }\n \n-        // And there we have it!\n-        return resetFloat(negative, integerPartLength, fractLen, expLen);\n+    // Ok; unless we hit end-of-input, need to push last char read back\n+    if (!eof) {\n+        --_inputPtr;\n+        // As per [core#105], need separating space between root values; check here\n+        if (_parsingContext.inRoot()) {\n+            _verifyRootSpace(c);\n+        }\n     }\n+    _textBuffer.setCurrentLength(outPtr);\n+\n+    // And there we have it!\n+    return resetFloat(negative, integerPartLength, fractLen, expLen);\n+}",
                    "line_numbers": [
                        1536,
                        1628
                    ],
                    "file_path": "src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java"
                }
            ],
            "is_multi_method": true,
            "coordination_notes": "",
            "methods_count": 2
        }
    ],
    "iterations": 1,
    "monitor_file": "traces/JacksonCore-19_trace.json"
}