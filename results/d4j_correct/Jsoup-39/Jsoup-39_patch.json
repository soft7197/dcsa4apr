{
    "bug_id": "Jsoup-39",
    "success": true,
    "error": null,
    "patch": null,
    "project_path": "/tmp/d4j_Jsoup-39_1757175518",
    "patches": [
        {
            "hypothesis": "The issue is that after detecting the UTF-8 BOM and discarding it, the method attempts to decode the byteData again without actually rebuilding the Document object if the charset is not originally set. As a result, the Document ends up being null or incorrectly built. The Document should be parsed again in the else branch if doc is set to null after decoding char data without parsing.",
            "fixed_method": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    byteData.rewind();\n    if (charsetName == null) { // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) { // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                    try {\n                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                            foundCharset = meta.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        foundCharset = null;\n                    }\n                }\n            } else {\n                foundCharset = meta.attr(\"charset\");\n            }\n            \n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = parser.parseInput(docData, baseUri);  // Re-parse the document\n            }\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    // UTF-8 BOM indicator. takes precedence over everything else. rarely used. re-decodes in case above decoded incorrectly\n    if (docData.length() > 0 && docData.charAt(0) == 65279) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        // Ensure we parse again after removing BOM\n        doc = parser.parseInput(docData, baseUri);\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    doc.outputSettings().charset(charsetName);  // Set charset before returning\n    return doc;\n}",
            "diff": "--- original\n+++ fixed\n@@ -1,14 +1,14 @@\n-// todo - this is getting gnarly. needs a rewrite.\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc = null;\n+    byteData.rewind();\n     if (charsetName == null) { // determine from meta. safe parse as UTF-8\n         // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n         docData = Charset.forName(defaultCharset).decode(byteData).toString();\n         doc = parser.parseInput(docData, baseUri);\n         Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n         if (meta != null) { // if not found, will keep utf-8 as best attempt\n-            String foundCharset;\n+            String foundCharset = null;\n             if (meta.hasAttr(\"http-equiv\")) {\n                 foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                 if (foundCharset == null && meta.hasAttr(\"charset\")) {\n@@ -23,29 +23,32 @@\n             } else {\n                 foundCharset = meta.attr(\"charset\");\n             }\n-\n+            \n             if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                 foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                 charsetName = foundCharset;\n                 byteData.rewind();\n                 docData = Charset.forName(foundCharset).decode(byteData).toString();\n-                doc = null;\n+                doc = parser.parseInput(docData, baseUri);  // Re-parse the document\n             }\n         }\n     } else { // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData = Charset.forName(charsetName).decode(byteData).toString();\n     }\n-    // UTF-8 BOM indicator. takes precedence over everything else. rarely used. re-decodes incase above decoded incorrectly\n+    // UTF-8 BOM indicator. takes precedence over everything else. rarely used. re-decodes in case above decoded incorrectly\n     if (docData.length() > 0 && docData.charAt(0) == 65279) {\n         byteData.rewind();\n         docData = Charset.forName(defaultCharset).decode(byteData).toString();\n         docData = docData.substring(1);\n         charsetName = defaultCharset;\n+        // Ensure we parse again after removing BOM\n+        doc = parser.parseInput(docData, baseUri);\n     }\n     if (doc == null) {\n         doc = parser.parseInput(docData, baseUri);\n         doc.outputSettings().charset(charsetName);\n     }\n+    doc.outputSettings().charset(charsetName);  // Set charset before returning\n     return doc;\n }",
            "file_path": "src/main/java/org/jsoup/helper/DataUtil.java",
            "method_name": "parseByteData",
            "class_name": "DataUtil",
            "iteration": 1,
            "is_multi_method": false,
            "line_numbers": [
                76,
                77,
                78,
                79,
                80,
                81,
                82,
                83,
                84,
                85,
                86,
                87,
                88,
                89,
                90,
                91,
                92,
                93,
                94,
                95,
                96,
                97,
                98,
                99,
                100,
                101,
                102,
                103,
                104,
                105,
                106,
                107,
                108,
                109,
                110,
                111,
                112,
                113,
                114,
                115,
                116,
                117,
                118,
                119,
                120,
                121,
                122,
                123,
                124,
                125
            ]
        }
    ],
    "iterations": 1,
    "monitor_file": "traces/Jsoup-39_trace.json"
}