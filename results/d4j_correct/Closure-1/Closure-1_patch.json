{
  "bug_id": "Closure-1",
  "success": true,
  "error": null,
  "patch": null,
  "project_path": "/tmp/d4j_Closure-1_1757755229",
  "patches": [
    {
      "hypothesis": "The method `removeUnreferencedFunctionArgs` is incorrectly removing function parameters even when the modification of callers is not allowed (in SIMPLE_OPTIMIZATIONS mode, for example). This results in parameters being stripped off where they should be retained. The fix is to ensure that parameters are only removed if the optimization level allows modifying callers and if the parameters are truly unreferenced.",
      "fixed_method": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n  Node function = fnScope.getRootNode();\n\n  Preconditions.checkState(function.isFunction());\n  if (NodeUtil.isGetOrSetKey(function.getParent())) {\n    // The parameters of object literal setters cannot be removed.\n    return;\n  }\n\n  Node argList = getFunctionArgList(function);\n  boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n\n  if (!modifyCallers) {\n    // If we can't modify callers, we shouldn't remove any parameters\n    // because SIMPLE_OPTIMIZATIONS (for instance) expects parameters to stay.\n    return;\n  }\n\n  // Strip unreferenced args off the end of the function declaration.\n  Node lastArg;\n  while ((lastArg = argList.getLastChild()) != null) {\n    Var var = fnScope.getVar(lastArg.getString());\n    if (!referenced.contains(var)) {\n      argList.removeChild(lastArg);\n      compiler.reportCodeChange();\n    } else {\n      break;\n    }\n  }\n\n  if (modifyCallers) {\n    callSiteOptimizer.optimize(fnScope, referenced);\n  }\n}",
      "diff": "--- original\n+++ fixed\n@@ -1,44 +1,34 @@\n-/**\n-* Removes unreferenced arguments from a function declaration and when\n-* possible the function's callSites.\n-*\n-* @param fnScope The scope inside the function\n-*/\n private void removeUnreferencedFunctionArgs(Scope fnScope) {\n-  // Notice that removing unreferenced function args breaks\n-  // Function.prototype.length. In advanced mode, we don't really care\n-  // about this: we consider \"length\" the equivalent of reflecting on\n-  // the function's lexical source.\n-  //\n-  // Rather than create a new option for this, we assume that if the user\n-  // is removing globals, then it's OK to remove unused function args.\n-  //\n-  // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n-\n   Node function = fnScope.getRootNode();\n \n   Preconditions.checkState(function.isFunction());\n   if (NodeUtil.isGetOrSetKey(function.getParent())) {\n-    // The parameters object literal setters can not be removed.\n+    // The parameters of object literal setters cannot be removed.\n     return;\n   }\n \n   Node argList = getFunctionArgList(function);\n-  boolean modifyCallers = modifyCallSites\n-      && callSiteOptimizer.canModifyCallers(function);\n+  boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n+\n   if (!modifyCallers) {\n-    // Strip unreferenced args off the end of the function declaration.\n-    Node lastArg;\n-    while ((lastArg = argList.getLastChild()) != null) {\n-      Var var = fnScope.getVar(lastArg.getString());\n-      if (!referenced.contains(var)) {\n-        argList.removeChild(lastArg);\n-        compiler.reportCodeChange();\n-      } else {\n-        break;\n-      }\n+    // If we can't modify callers, we shouldn't remove any parameters\n+    // because SIMPLE_OPTIMIZATIONS (for instance) expects parameters to stay.\n+    return;\n+  }\n+\n+  // Strip unreferenced args off the end of the function declaration.\n+  Node lastArg;\n+  while ((lastArg = argList.getLastChild()) != null) {\n+    Var var = fnScope.getVar(lastArg.getString());\n+    if (!referenced.contains(var)) {\n+      argList.removeChild(lastArg);\n+      compiler.reportCodeChange();\n+    } else {\n+      break;\n     }\n-  } else {\n+  }\n+\n+  if (modifyCallers) {\n     callSiteOptimizer.optimize(fnScope, referenced);\n   }\n }",
      "file_path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
      "method_name": "removeUnreferencedFunctionArgs",
      "class_name": "RemoveUnusedVars",
      "iteration": 2,
      "is_multi_method": false,
      "line_numbers": [
        369,
        370,
        371,
        372,
        373,
        374,
        375,
        376,
        377,
        378,
        379,
        380,
        381,
        382,
        383,
        384,
        385,
        386,
        387,
        388,
        389,
        390,
        391,
        392,
        393,
        394,
        395,
        396,
        397,
        398,
        399,
        400,
        401,
        402,
        403,
        404,
        405,
        406
      ],
      "original_code": "/**\n* Removes unreferenced arguments from a function declaration and when\n* possible the function's callSites.\n*\n* @param fnScope The scope inside the function\n*/\nprivate void removeUnreferencedFunctionArgs(Scope fnScope) {\n  // Notice that removing unreferenced function args breaks\n  // Function.prototype.length. In advanced mode, we don't really care\n  // about this: we consider \"length\" the equivalent of reflecting on\n  // the function's lexical source.\n  //\n  // Rather than create a new option for this, we assume that if the user\n  // is removing globals, then it's OK to remove unused function args.\n  //\n  // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n\n  Node function = fnScope.getRootNode();\n\n  Preconditions.checkState(function.isFunction());\n  if (NodeUtil.isGetOrSetKey(function.getParent())) {\n    // The parameters object literal setters can not be removed.\n    return;\n  }\n\n  Node argList = getFunctionArgList(function);\n  boolean modifyCallers = modifyCallSites\n      && callSiteOptimizer.canModifyCallers(function);\n  if (!modifyCallers) {\n    // Strip unreferenced args off the end of the function declaration.\n    Node lastArg;\n    while ((lastArg = argList.getLastChild()) != null) {\n      Var var = fnScope.getVar(lastArg.getString());\n      if (!referenced.contains(var)) {\n        argList.removeChild(lastArg);\n        compiler.reportCodeChange();\n      } else {\n        break;\n      }\n    }\n  } else {\n    callSiteOptimizer.optimize(fnScope, referenced);\n  }\n}"
    }
  ],
  "iterations": 2,
  "monitor_file": "traces/Closure-1_trace.json"
}