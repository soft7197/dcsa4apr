{
  "bug_id": "Time-12",
  "success": true,
  "error": null,
  "patch": null,
  "project_path": "/tmp/d4j_Time-12_1759396276",
  "patches": [
    [
      {
        "hypothesis": "The method incorrectly handles dates before the year zero (BC era). The Java Date class represents years in the AD/BC format but does not account for the era directly. We need to adjust the year calculation based on the era to handle BC years correctly.",
        "fixed_method": "public static LocalDateTime fromDateFields(Date date) {\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    GregorianCalendar cal = new GregorianCalendar();\n    cal.setTime(date);\n    int year = cal.get(Calendar.YEAR);\n    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = -(year - 1); // Convert BC year to negative ISO year\n    }\n    return new LocalDateTime(\n        year,\n        date.getMonth() + 1,\n        date.getDate(),\n        date.getHours(),\n        date.getMinutes(),\n        date.getSeconds(),\n        (((int) (date.getTime() % 1000)) + 1000) % 1000\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,37 +1,20 @@\n-    /**\n-     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Date and assigned to the LocalDateTime.\n-     * This is useful if you have been using the Date as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method always creates a LocalDateTime with ISO chronology.\n-     *\n-     * @param date  the Date to extract fields from, not null\n-     * @return the created local date-time, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    @SuppressWarnings(\"deprecation\")\n-    public static LocalDateTime fromDateFields(Date date) {\n-        if (date == null) {\n-            throw new IllegalArgumentException(\"The date must not be null\");\n-        }\n-            // handle years in era BC\n-        return new LocalDateTime(\n-            date.getYear() + 1900,\n-            date.getMonth() + 1,\n-            date.getDate(),\n-            date.getHours(),\n-            date.getMinutes(),\n-            date.getSeconds(),\n-            (((int) (date.getTime() % 1000)) + 1000) % 1000\n-        );\n+public static LocalDateTime fromDateFields(Date date) {\n+    if (date == null) {\n+        throw new IllegalArgumentException(\"The date must not be null\");\n     }\n+    GregorianCalendar cal = new GregorianCalendar();\n+    cal.setTime(date);\n+    int year = cal.get(Calendar.YEAR);\n+    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        year = -(year - 1); // Convert BC year to negative ISO year\n+    }\n+    return new LocalDateTime(\n+        year,\n+        date.getMonth() + 1,\n+        date.getDate(),\n+        date.getHours(),\n+        date.getMinutes(),\n+        date.getSeconds(),\n+        (((int) (date.getTime() % 1000)) + 1000) % 1000\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDateTime.java",
        "method_name": "fromDateFields",
        "class_name": "LocalDateTime",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          231,
          247
        ],
        "original_code": "    /**\n     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDateTime.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDateTime with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDateTime(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }\n"
      },
      {
        "hypothesis": "The issue arises from the handling of dates before the common era (BCE). The Date class does not natively support negative years, and when the year is set as BC in a GregorianCalendar, the conversion to the Date object does not reflect the BC era correctly. The method needs to account for the BC era by adjusting the year appropriately before passing it to the LocalDateTime constructor.",
        "fixed_method": "public static LocalDateTime fromDateFields(Date date) {\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    GregorianCalendar cal = new GregorianCalendar();\n    cal.setTime(date);\n    int year = cal.get(Calendar.YEAR);\n    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = -(year - 1); // Adjust for BC era\n    }\n    return new LocalDateTime(\n        year,\n        cal.get(Calendar.MONTH) + 1,\n        cal.get(Calendar.DAY_OF_MONTH),\n        cal.get(Calendar.HOUR_OF_DAY),\n        cal.get(Calendar.MINUTE),\n        cal.get(Calendar.SECOND),\n        cal.get(Calendar.MILLISECOND)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,37 +1,20 @@\n-    /**\n-     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Date and assigned to the LocalDateTime.\n-     * This is useful if you have been using the Date as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method always creates a LocalDateTime with ISO chronology.\n-     *\n-     * @param date  the Date to extract fields from, not null\n-     * @return the created local date-time, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    @SuppressWarnings(\"deprecation\")\n-    public static LocalDateTime fromDateFields(Date date) {\n-        if (date == null) {\n-            throw new IllegalArgumentException(\"The date must not be null\");\n-        }\n-            // handle years in era BC\n-        return new LocalDateTime(\n-            date.getYear() + 1900,\n-            date.getMonth() + 1,\n-            date.getDate(),\n-            date.getHours(),\n-            date.getMinutes(),\n-            date.getSeconds(),\n-            (((int) (date.getTime() % 1000)) + 1000) % 1000\n-        );\n+public static LocalDateTime fromDateFields(Date date) {\n+    if (date == null) {\n+        throw new IllegalArgumentException(\"The date must not be null\");\n     }\n+    GregorianCalendar cal = new GregorianCalendar();\n+    cal.setTime(date);\n+    int year = cal.get(Calendar.YEAR);\n+    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        year = -(year - 1); // Adjust for BC era\n+    }\n+    return new LocalDateTime(\n+        year,\n+        cal.get(Calendar.MONTH) + 1,\n+        cal.get(Calendar.DAY_OF_MONTH),\n+        cal.get(Calendar.HOUR_OF_DAY),\n+        cal.get(Calendar.MINUTE),\n+        cal.get(Calendar.SECOND),\n+        cal.get(Calendar.MILLISECOND)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDateTime.java",
        "method_name": "fromDateFields",
        "class_name": "LocalDateTime",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          231,
          247
        ],
        "original_code": "    /**\n     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDateTime.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDateTime with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDateTime(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }\n"
      },
      {
        "hypothesis": "The initial patch overfits by not fully utilizing the capabilities of the GregorianCalendar to handle all aspects of date conversion, particularly around the transition from BC to AD and leap year considerations. It continues to use deprecated methods like date.getMonth() and date.getDate(), which are not always consistent with modern calendars. The refined patch should use GregorianCalendar for all date field extractions to ensure consistency with ISO chronology and properly handle edge cases such as leap years and transitions between BC and AD.",
        "fixed_method": "public static LocalDateTime fromDateFields(Date date) {\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    GregorianCalendar cal = new GregorianCalendar();\n    cal.setTime(date);\n    int year = cal.get(Calendar.YEAR);\n    int month = cal.get(Calendar.MONTH) + 1;\n    int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);\n    int hourOfDay = cal.get(Calendar.HOUR_OF_DAY);\n    int minute = cal.get(Calendar.MINUTE);\n    int second = cal.get(Calendar.SECOND);\n    int millisecond = cal.get(Calendar.MILLISECOND);\n    \n    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = 1 - year; // Adjust for BC era\n    }\n    \n    return new LocalDateTime(\n        year,\n        month,\n        dayOfMonth,\n        hourOfDay,\n        minute,\n        second,\n        millisecond\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -5,16 +5,24 @@\n     GregorianCalendar cal = new GregorianCalendar();\n     cal.setTime(date);\n     int year = cal.get(Calendar.YEAR);\n+    int month = cal.get(Calendar.MONTH) + 1;\n+    int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);\n+    int hourOfDay = cal.get(Calendar.HOUR_OF_DAY);\n+    int minute = cal.get(Calendar.MINUTE);\n+    int second = cal.get(Calendar.SECOND);\n+    int millisecond = cal.get(Calendar.MILLISECOND);\n+    \n     if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n         year = 1 - year; // Adjust for BC era\n     }\n+    \n     return new LocalDateTime(\n         year,\n-        date.getMonth() + 1,\n-        date.getDate(),\n-        date.getHours(),\n-        date.getMinutes(),\n-        date.getSeconds(),\n-        (((int) (date.getTime() % 1000)) + 1000) % 1000\n+        month,\n+        dayOfMonth,\n+        hourOfDay,\n+        minute,\n+        second,\n+        millisecond\n     );\n }",
        "file_path": "src/main/java/org/joda/time/LocalDateTime.java",
        "method_name": "fromDateFields",
        "class_name": "LocalDateTime",
        "iteration": 1,
        "is_refinement": true,
        "refinement_attempt": 1,
        "original_hypothesis": "The bug arises because the conversion from java.util.Date does not correctly handle years in the BC era. In the GregorianCalendar, years in the BC era are represented as negative numbers, but the 'date.getYear()' method returns the year as an offset from 1900, without considering the era. Therefore, we need to adjust the calculation for years when the date is in the BC era.",
        "line_numbers": [
          231,
          247
        ]
      },
      {
        "hypothesis": "The bug is caused by not correctly handling the BC era when converting a Date to a LocalDateTime. The GregorianCalendar in BC era represents years as positive numbers, but LocalDateTime expects years to be negative for BC (i.e., year 1 BC is year 0, year 2 BC is year -1). The current code does not account for this conversion, leading to incorrect year values for dates in BC era.",
        "fixed_method": "public static LocalDateTime fromDateFields(Date date) {\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    GregorianCalendar cal = new GregorianCalendar();\n    cal.setTime(date);\n    int year = cal.get(Calendar.YEAR);\n    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = -(year - 1); // Convert BC year to negative representation\n    }\n    return new LocalDateTime(\n        year,\n        cal.get(Calendar.MONTH) + 1,\n        cal.get(Calendar.DAY_OF_MONTH),\n        cal.get(Calendar.HOUR_OF_DAY),\n        cal.get(Calendar.MINUTE),\n        cal.get(Calendar.SECOND),\n        cal.get(Calendar.MILLISECOND)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,37 +1,20 @@\n-    /**\n-     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Date and assigned to the LocalDateTime.\n-     * This is useful if you have been using the Date as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method always creates a LocalDateTime with ISO chronology.\n-     *\n-     * @param date  the Date to extract fields from, not null\n-     * @return the created local date-time, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    @SuppressWarnings(\"deprecation\")\n-    public static LocalDateTime fromDateFields(Date date) {\n-        if (date == null) {\n-            throw new IllegalArgumentException(\"The date must not be null\");\n-        }\n-            // handle years in era BC\n-        return new LocalDateTime(\n-            date.getYear() + 1900,\n-            date.getMonth() + 1,\n-            date.getDate(),\n-            date.getHours(),\n-            date.getMinutes(),\n-            date.getSeconds(),\n-            (((int) (date.getTime() % 1000)) + 1000) % 1000\n-        );\n+public static LocalDateTime fromDateFields(Date date) {\n+    if (date == null) {\n+        throw new IllegalArgumentException(\"The date must not be null\");\n     }\n+    GregorianCalendar cal = new GregorianCalendar();\n+    cal.setTime(date);\n+    int year = cal.get(Calendar.YEAR);\n+    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        year = -(year - 1); // Convert BC year to negative representation\n+    }\n+    return new LocalDateTime(\n+        year,\n+        cal.get(Calendar.MONTH) + 1,\n+        cal.get(Calendar.DAY_OF_MONTH),\n+        cal.get(Calendar.HOUR_OF_DAY),\n+        cal.get(Calendar.MINUTE),\n+        cal.get(Calendar.SECOND),\n+        cal.get(Calendar.MILLISECOND)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDateTime.java",
        "method_name": "fromDateFields",
        "class_name": "LocalDateTime",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          231,
          247
        ],
        "original_code": "    /**\n     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDateTime.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDateTime with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDateTime(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }\n"
      },
      {
        "hypothesis": "The bug is caused by the incorrect handling of BC years when converting from a Date object to a LocalDateTime object. The current implementation does not account for the BC era, leading to incorrect year values being calculated. The year should be negated and adjusted by subtracting 1 when the calendar era is BC, to compensate for the fact that there is no year zero in the Gregorian calendar.",
        "fixed_method": "public static LocalDateTime fromDateFields(Date date) {\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    int year = date.getYear() + 1900;\n    GregorianCalendar cal = new GregorianCalendar();\n    cal.setTime(date);\n    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = -(year - 1);\n    }\n    return new LocalDateTime(\n        year,\n        date.getMonth() + 1,\n        date.getDate(),\n        date.getHours(),\n        date.getMinutes(),\n        date.getSeconds(),\n        (((int) (date.getTime() % 1000)) + 1000) % 1000\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,37 +1,20 @@\n-    /**\n-     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Date and assigned to the LocalDateTime.\n-     * This is useful if you have been using the Date as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method always creates a LocalDateTime with ISO chronology.\n-     *\n-     * @param date  the Date to extract fields from, not null\n-     * @return the created local date-time, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    @SuppressWarnings(\"deprecation\")\n-    public static LocalDateTime fromDateFields(Date date) {\n-        if (date == null) {\n-            throw new IllegalArgumentException(\"The date must not be null\");\n-        }\n-            // handle years in era BC\n-        return new LocalDateTime(\n-            date.getYear() + 1900,\n-            date.getMonth() + 1,\n-            date.getDate(),\n-            date.getHours(),\n-            date.getMinutes(),\n-            date.getSeconds(),\n-            (((int) (date.getTime() % 1000)) + 1000) % 1000\n-        );\n+public static LocalDateTime fromDateFields(Date date) {\n+    if (date == null) {\n+        throw new IllegalArgumentException(\"The date must not be null\");\n     }\n+    int year = date.getYear() + 1900;\n+    GregorianCalendar cal = new GregorianCalendar();\n+    cal.setTime(date);\n+    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        year = -(year - 1);\n+    }\n+    return new LocalDateTime(\n+        year,\n+        date.getMonth() + 1,\n+        date.getDate(),\n+        date.getHours(),\n+        date.getMinutes(),\n+        date.getSeconds(),\n+        (((int) (date.getTime() % 1000)) + 1000) % 1000\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDateTime.java",
        "method_name": "fromDateFields",
        "class_name": "LocalDateTime",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          231,
          247
        ],
        "original_code": "    /**\n     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDateTime.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDateTime with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDateTime(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }\n"
      },
      {
        "hypothesis": "The issue stems from the handling of dates that are in the BC era. The method currently assumes all years are AD and directly adds 1900 to the year obtained from the Date object. For BC dates, this results in incorrect year calculations. The fix involves correctly handling the BC era by adjusting the year calculation to account for the era field.",
        "fixed_method": "public static LocalDateTime fromDateFields(Date date) {\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    GregorianCalendar cal = new GregorianCalendar();\n    cal.setTime(date);\n    int year = cal.get(Calendar.YEAR);\n    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = 1 - year; // Convert to negative or zero for BC\n    }\n    return new LocalDateTime(\n        year,\n        cal.get(Calendar.MONTH) + 1,\n        cal.get(Calendar.DAY_OF_MONTH),\n        cal.get(Calendar.HOUR_OF_DAY),\n        cal.get(Calendar.MINUTE),\n        cal.get(Calendar.SECOND),\n        cal.get(Calendar.MILLISECOND)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,37 +1,20 @@\n-    /**\n-     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Date and assigned to the LocalDateTime.\n-     * This is useful if you have been using the Date as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method always creates a LocalDateTime with ISO chronology.\n-     *\n-     * @param date  the Date to extract fields from, not null\n-     * @return the created local date-time, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    @SuppressWarnings(\"deprecation\")\n-    public static LocalDateTime fromDateFields(Date date) {\n-        if (date == null) {\n-            throw new IllegalArgumentException(\"The date must not be null\");\n-        }\n-            // handle years in era BC\n-        return new LocalDateTime(\n-            date.getYear() + 1900,\n-            date.getMonth() + 1,\n-            date.getDate(),\n-            date.getHours(),\n-            date.getMinutes(),\n-            date.getSeconds(),\n-            (((int) (date.getTime() % 1000)) + 1000) % 1000\n-        );\n+public static LocalDateTime fromDateFields(Date date) {\n+    if (date == null) {\n+        throw new IllegalArgumentException(\"The date must not be null\");\n     }\n+    GregorianCalendar cal = new GregorianCalendar();\n+    cal.setTime(date);\n+    int year = cal.get(Calendar.YEAR);\n+    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        year = 1 - year; // Convert to negative or zero for BC\n+    }\n+    return new LocalDateTime(\n+        year,\n+        cal.get(Calendar.MONTH) + 1,\n+        cal.get(Calendar.DAY_OF_MONTH),\n+        cal.get(Calendar.HOUR_OF_DAY),\n+        cal.get(Calendar.MINUTE),\n+        cal.get(Calendar.SECOND),\n+        cal.get(Calendar.MILLISECOND)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDateTime.java",
        "method_name": "fromDateFields",
        "class_name": "LocalDateTime",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          231,
          247
        ],
        "original_code": "    /**\n     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDateTime.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDateTime with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDateTime(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }\n"
      },
      {
        "hypothesis": "The bug arises from the incorrect handling of BC (Before Christ) years in the Java `Date` object. The `Date.getYear()` method returns the year minus 1900, which is not suitable for BC years because BC years should be represented as negative. When the year is in the BC era, the year should be negated and decremented by 1 to match the proleptic Gregorian calendar used by Joda-Time's LocalDateTime.",
        "fixed_method": "public static LocalDateTime fromDateFields(Date date) {\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    GregorianCalendar cal = new GregorianCalendar();\n    cal.setTime(date);\n    int year = cal.get(Calendar.YEAR);\n    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = -(year - 1); // Convert to negative year and adjust by subtracting 1\n    }\n    return new LocalDateTime(\n        year,\n        cal.get(Calendar.MONTH) + 1, // Calendar.MONTH is zero-based\n        cal.get(Calendar.DAY_OF_MONTH),\n        cal.get(Calendar.HOUR_OF_DAY),\n        cal.get(Calendar.MINUTE),\n        cal.get(Calendar.SECOND),\n        cal.get(Calendar.MILLISECOND)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,37 +1,20 @@\n-    /**\n-     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Date and assigned to the LocalDateTime.\n-     * This is useful if you have been using the Date as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method always creates a LocalDateTime with ISO chronology.\n-     *\n-     * @param date  the Date to extract fields from, not null\n-     * @return the created local date-time, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    @SuppressWarnings(\"deprecation\")\n-    public static LocalDateTime fromDateFields(Date date) {\n-        if (date == null) {\n-            throw new IllegalArgumentException(\"The date must not be null\");\n-        }\n-            // handle years in era BC\n-        return new LocalDateTime(\n-            date.getYear() + 1900,\n-            date.getMonth() + 1,\n-            date.getDate(),\n-            date.getHours(),\n-            date.getMinutes(),\n-            date.getSeconds(),\n-            (((int) (date.getTime() % 1000)) + 1000) % 1000\n-        );\n+public static LocalDateTime fromDateFields(Date date) {\n+    if (date == null) {\n+        throw new IllegalArgumentException(\"The date must not be null\");\n     }\n+    GregorianCalendar cal = new GregorianCalendar();\n+    cal.setTime(date);\n+    int year = cal.get(Calendar.YEAR);\n+    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        year = -(year - 1); // Convert to negative year and adjust by subtracting 1\n+    }\n+    return new LocalDateTime(\n+        year,\n+        cal.get(Calendar.MONTH) + 1, // Calendar.MONTH is zero-based\n+        cal.get(Calendar.DAY_OF_MONTH),\n+        cal.get(Calendar.HOUR_OF_DAY),\n+        cal.get(Calendar.MINUTE),\n+        cal.get(Calendar.SECOND),\n+        cal.get(Calendar.MILLISECOND)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDateTime.java",
        "method_name": "fromDateFields",
        "class_name": "LocalDateTime",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          231,
          247
        ],
        "original_code": "    /**\n     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDateTime.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDateTime with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDateTime(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }\n"
      }
    ],
    [
      {
        "hypothesis": "The bug is caused by not accounting for the era (BC or AD) when extracting the year from the Calendar object. The Calendar.YEAR field returns the year within the era, but to handle years before year zero correctly, we need to adjust the year based on the era setting.",
        "fixed_method": "public static LocalDateTime fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int yearOfEra = calendar.get(Calendar.YEAR);\n    int era = calendar.get(Calendar.ERA);\n    int year = (era == GregorianCalendar.BC) ? 1 - yearOfEra : yearOfEra;\n    return new LocalDateTime(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH),\n        calendar.get(Calendar.HOUR_OF_DAY),\n        calendar.get(Calendar.MINUTE),\n        calendar.get(Calendar.SECOND),\n        calendar.get(Calendar.MILLISECOND)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,40 +1,17 @@\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n-     * This is useful if you have been using the Calendar as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method ignores the type of the calendar and always\n-     * creates a LocalDateTime with ISO chronology. It is expected that you\n-     * will only pass in instances of <code>GregorianCalendar</code> however\n-     * this is not validated.\n-     *\n-     * @param calendar  the Calendar to extract fields from, not null\n-     * @return the created local date-time, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n-        if (calendar == null) {\n-            throw new IllegalArgumentException(\"The calendar must not be null\");\n-        }\n-        int yearOfEra = calendar.get(Calendar.YEAR);\n-        return new LocalDateTime(\n-            yearOfEra,\n-            calendar.get(Calendar.MONTH) + 1,\n-            calendar.get(Calendar.DAY_OF_MONTH),\n-            calendar.get(Calendar.HOUR_OF_DAY),\n-            calendar.get(Calendar.MINUTE),\n-            calendar.get(Calendar.SECOND),\n-            calendar.get(Calendar.MILLISECOND)\n-        );\n+public static LocalDateTime fromCalendarFields(Calendar calendar) {\n+    if (calendar == null) {\n+        throw new IllegalArgumentException(\"The calendar must not be null\");\n     }\n+    int yearOfEra = calendar.get(Calendar.YEAR);\n+    int era = calendar.get(Calendar.ERA);\n+    int year = (era == GregorianCalendar.BC) ? 1 - yearOfEra : yearOfEra;\n+    return new LocalDateTime(\n+        year,\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH),\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        calendar.get(Calendar.MILLISECOND)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDateTime.java",
        "method_name": "fromCalendarFields",
        "class_name": "LocalDateTime",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          195,
          210
        ],
        "original_code": "    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }\n"
      },
      {
        "hypothesis": "The bug is related to handling the GregorianCalendar's BC era, where the year should be adjusted to match the '0' and negative years in the LocalDateTime representation. The Java Calendar.YEAR field provides the year of the era, which needs to be adjusted when the era is BC.",
        "fixed_method": "public static LocalDateTime fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int year = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = -(year - 1); // Adjust for BC era\n    }\n    return new LocalDateTime(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH),\n        calendar.get(Calendar.HOUR_OF_DAY),\n        calendar.get(Calendar.MINUTE),\n        calendar.get(Calendar.SECOND),\n        calendar.get(Calendar.MILLISECOND)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,40 +1,18 @@\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n-     * This is useful if you have been using the Calendar as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method ignores the type of the calendar and always\n-     * creates a LocalDateTime with ISO chronology. It is expected that you\n-     * will only pass in instances of <code>GregorianCalendar</code> however\n-     * this is not validated.\n-     *\n-     * @param calendar  the Calendar to extract fields from, not null\n-     * @return the created local date-time, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n-        if (calendar == null) {\n-            throw new IllegalArgumentException(\"The calendar must not be null\");\n-        }\n-        int yearOfEra = calendar.get(Calendar.YEAR);\n-        return new LocalDateTime(\n-            yearOfEra,\n-            calendar.get(Calendar.MONTH) + 1,\n-            calendar.get(Calendar.DAY_OF_MONTH),\n-            calendar.get(Calendar.HOUR_OF_DAY),\n-            calendar.get(Calendar.MINUTE),\n-            calendar.get(Calendar.SECOND),\n-            calendar.get(Calendar.MILLISECOND)\n-        );\n+public static LocalDateTime fromCalendarFields(Calendar calendar) {\n+    if (calendar == null) {\n+        throw new IllegalArgumentException(\"The calendar must not be null\");\n     }\n+    int year = calendar.get(Calendar.YEAR);\n+    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        year = -(year - 1); // Adjust for BC era\n+    }\n+    return new LocalDateTime(\n+        year,\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH),\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        calendar.get(Calendar.MILLISECOND)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDateTime.java",
        "method_name": "fromCalendarFields",
        "class_name": "LocalDateTime",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          195,
          210
        ],
        "original_code": "    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }\n"
      },
      {
        "hypothesis": "The bug in the method is that it does not correctly handle the BC (Before Christ) era for years. In the Gregorian calendar, years before AD 1 are represented in BC with year 1 BC being 0, 2 BC being -1, etc. The original method ignores the ERA field and directly uses the YEAR field, which leads to incorrect LocalDateTime creation for BC dates.",
        "fixed_method": "public static LocalDateTime fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int year = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = 1 - year; // Adjust year for BC era\n    }\n    return new LocalDateTime(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH),\n        calendar.get(Calendar.HOUR_OF_DAY),\n        calendar.get(Calendar.MINUTE),\n        calendar.get(Calendar.SECOND),\n        calendar.get(Calendar.MILLISECOND)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,40 +1,18 @@\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n-     * This is useful if you have been using the Calendar as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method ignores the type of the calendar and always\n-     * creates a LocalDateTime with ISO chronology. It is expected that you\n-     * will only pass in instances of <code>GregorianCalendar</code> however\n-     * this is not validated.\n-     *\n-     * @param calendar  the Calendar to extract fields from, not null\n-     * @return the created local date-time, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n-        if (calendar == null) {\n-            throw new IllegalArgumentException(\"The calendar must not be null\");\n-        }\n-        int yearOfEra = calendar.get(Calendar.YEAR);\n-        return new LocalDateTime(\n-            yearOfEra,\n-            calendar.get(Calendar.MONTH) + 1,\n-            calendar.get(Calendar.DAY_OF_MONTH),\n-            calendar.get(Calendar.HOUR_OF_DAY),\n-            calendar.get(Calendar.MINUTE),\n-            calendar.get(Calendar.SECOND),\n-            calendar.get(Calendar.MILLISECOND)\n-        );\n+public static LocalDateTime fromCalendarFields(Calendar calendar) {\n+    if (calendar == null) {\n+        throw new IllegalArgumentException(\"The calendar must not be null\");\n     }\n+    int year = calendar.get(Calendar.YEAR);\n+    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        year = 1 - year; // Adjust year for BC era\n+    }\n+    return new LocalDateTime(\n+        year,\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH),\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        calendar.get(Calendar.MILLISECOND)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDateTime.java",
        "method_name": "fromCalendarFields",
        "class_name": "LocalDateTime",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          195,
          210
        ],
        "original_code": "    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }\n"
      },
      {
        "hypothesis": "The bug is due to the method not handling the BC (Before Christ) era correctly. The Calendar.YEAR returns a positive number even for BC years, but the LocalDateTime expects negative numbers for years before year zero. The fix involves adjusting the year value based on the era.",
        "fixed_method": "public static LocalDateTime fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int year = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = 1 - year; // Adjust for BC\n    }\n    return new LocalDateTime(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH),\n        calendar.get(Calendar.HOUR_OF_DAY),\n        calendar.get(Calendar.MINUTE),\n        calendar.get(Calendar.SECOND),\n        calendar.get(Calendar.MILLISECOND)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,40 +1,18 @@\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n-     * This is useful if you have been using the Calendar as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method ignores the type of the calendar and always\n-     * creates a LocalDateTime with ISO chronology. It is expected that you\n-     * will only pass in instances of <code>GregorianCalendar</code> however\n-     * this is not validated.\n-     *\n-     * @param calendar  the Calendar to extract fields from, not null\n-     * @return the created local date-time, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n-        if (calendar == null) {\n-            throw new IllegalArgumentException(\"The calendar must not be null\");\n-        }\n-        int yearOfEra = calendar.get(Calendar.YEAR);\n-        return new LocalDateTime(\n-            yearOfEra,\n-            calendar.get(Calendar.MONTH) + 1,\n-            calendar.get(Calendar.DAY_OF_MONTH),\n-            calendar.get(Calendar.HOUR_OF_DAY),\n-            calendar.get(Calendar.MINUTE),\n-            calendar.get(Calendar.SECOND),\n-            calendar.get(Calendar.MILLISECOND)\n-        );\n+public static LocalDateTime fromCalendarFields(Calendar calendar) {\n+    if (calendar == null) {\n+        throw new IllegalArgumentException(\"The calendar must not be null\");\n     }\n+    int year = calendar.get(Calendar.YEAR);\n+    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        year = 1 - year; // Adjust for BC\n+    }\n+    return new LocalDateTime(\n+        year,\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH),\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        calendar.get(Calendar.MILLISECOND)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDateTime.java",
        "method_name": "fromCalendarFields",
        "class_name": "LocalDateTime",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          195,
          210
        ],
        "original_code": "    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }\n"
      },
      {
        "hypothesis": "The bug is due to the method not correctly handling the BC (Before Christ) era in the Gregorian calendar. The method currently assumes all years are AD (Anno Domini), which is why it produces incorrect years when the calendar is set to BC. The fix involves adjusting the year calculation when the calendar is set to the BC era, by subtracting the year from 1 to convert it to the negative year representation used by LocalDateTime.",
        "fixed_method": "public static LocalDateTime fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int year = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = 1 - year; // Convert BC year to negative\n    }\n    return new LocalDateTime(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH),\n        calendar.get(Calendar.HOUR_OF_DAY),\n        calendar.get(Calendar.MINUTE),\n        calendar.get(Calendar.SECOND),\n        calendar.get(Calendar.MILLISECOND)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,40 +1,18 @@\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n-     * This is useful if you have been using the Calendar as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method ignores the type of the calendar and always\n-     * creates a LocalDateTime with ISO chronology. It is expected that you\n-     * will only pass in instances of <code>GregorianCalendar</code> however\n-     * this is not validated.\n-     *\n-     * @param calendar  the Calendar to extract fields from, not null\n-     * @return the created local date-time, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n-        if (calendar == null) {\n-            throw new IllegalArgumentException(\"The calendar must not be null\");\n-        }\n-        int yearOfEra = calendar.get(Calendar.YEAR);\n-        return new LocalDateTime(\n-            yearOfEra,\n-            calendar.get(Calendar.MONTH) + 1,\n-            calendar.get(Calendar.DAY_OF_MONTH),\n-            calendar.get(Calendar.HOUR_OF_DAY),\n-            calendar.get(Calendar.MINUTE),\n-            calendar.get(Calendar.SECOND),\n-            calendar.get(Calendar.MILLISECOND)\n-        );\n+public static LocalDateTime fromCalendarFields(Calendar calendar) {\n+    if (calendar == null) {\n+        throw new IllegalArgumentException(\"The calendar must not be null\");\n     }\n+    int year = calendar.get(Calendar.YEAR);\n+    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        year = 1 - year; // Convert BC year to negative\n+    }\n+    return new LocalDateTime(\n+        year,\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH),\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        calendar.get(Calendar.MILLISECOND)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDateTime.java",
        "method_name": "fromCalendarFields",
        "class_name": "LocalDateTime",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          195,
          210
        ],
        "original_code": "    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }\n"
      },
      {
        "hypothesis": "The bug occurs because the method does not account for the era when converting the year from the Calendar instance to LocalDateTime. The GregorianCalendar uses different year numbering for BC (Before Christ) years, which needs to be adjusted when converting to a LocalDateTime that uses ISO chronology. The year should be negated and decremented by 1 when the era is BC.",
        "fixed_method": "public static LocalDateTime fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int year = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = -(year - 1);\n    }\n    return new LocalDateTime(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH),\n        calendar.get(Calendar.HOUR_OF_DAY),\n        calendar.get(Calendar.MINUTE),\n        calendar.get(Calendar.SECOND),\n        calendar.get(Calendar.MILLISECOND)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,40 +1,18 @@\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n-     * This is useful if you have been using the Calendar as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method ignores the type of the calendar and always\n-     * creates a LocalDateTime with ISO chronology. It is expected that you\n-     * will only pass in instances of <code>GregorianCalendar</code> however\n-     * this is not validated.\n-     *\n-     * @param calendar  the Calendar to extract fields from, not null\n-     * @return the created local date-time, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n-        if (calendar == null) {\n-            throw new IllegalArgumentException(\"The calendar must not be null\");\n-        }\n-        int yearOfEra = calendar.get(Calendar.YEAR);\n-        return new LocalDateTime(\n-            yearOfEra,\n-            calendar.get(Calendar.MONTH) + 1,\n-            calendar.get(Calendar.DAY_OF_MONTH),\n-            calendar.get(Calendar.HOUR_OF_DAY),\n-            calendar.get(Calendar.MINUTE),\n-            calendar.get(Calendar.SECOND),\n-            calendar.get(Calendar.MILLISECOND)\n-        );\n+public static LocalDateTime fromCalendarFields(Calendar calendar) {\n+    if (calendar == null) {\n+        throw new IllegalArgumentException(\"The calendar must not be null\");\n     }\n+    int year = calendar.get(Calendar.YEAR);\n+    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        year = -(year - 1);\n+    }\n+    return new LocalDateTime(\n+        year,\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH),\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        calendar.get(Calendar.MILLISECOND)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDateTime.java",
        "method_name": "fromCalendarFields",
        "class_name": "LocalDateTime",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          195,
          210
        ],
        "original_code": "    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }\n"
      },
      {
        "hypothesis": "The bug is related to the handling of years in the BC era. The original code does not account for the BC era when converting the year from the Calendar object, leading to incorrect year values for dates before year zero. The GregorianCalendar represents years in BC as positive numbers, but they should be converted to negative years in LocalDateTime, with 1 BC being year 0, 2 BC being year -1, etc.",
        "fixed_method": "public static LocalDateTime fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int yearOfEra = calendar.get(Calendar.YEAR);\n    int era = calendar.get(Calendar.ERA);\n    int year = (era == GregorianCalendar.AD) ? yearOfEra : -(yearOfEra - 1);\n    return new LocalDateTime(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH),\n        calendar.get(Calendar.HOUR_OF_DAY),\n        calendar.get(Calendar.MINUTE),\n        calendar.get(Calendar.SECOND),\n        calendar.get(Calendar.MILLISECOND)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,40 +1,17 @@\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n-     * This is useful if you have been using the Calendar as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method ignores the type of the calendar and always\n-     * creates a LocalDateTime with ISO chronology. It is expected that you\n-     * will only pass in instances of <code>GregorianCalendar</code> however\n-     * this is not validated.\n-     *\n-     * @param calendar  the Calendar to extract fields from, not null\n-     * @return the created local date-time, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n-        if (calendar == null) {\n-            throw new IllegalArgumentException(\"The calendar must not be null\");\n-        }\n-        int yearOfEra = calendar.get(Calendar.YEAR);\n-        return new LocalDateTime(\n-            yearOfEra,\n-            calendar.get(Calendar.MONTH) + 1,\n-            calendar.get(Calendar.DAY_OF_MONTH),\n-            calendar.get(Calendar.HOUR_OF_DAY),\n-            calendar.get(Calendar.MINUTE),\n-            calendar.get(Calendar.SECOND),\n-            calendar.get(Calendar.MILLISECOND)\n-        );\n+public static LocalDateTime fromCalendarFields(Calendar calendar) {\n+    if (calendar == null) {\n+        throw new IllegalArgumentException(\"The calendar must not be null\");\n     }\n+    int yearOfEra = calendar.get(Calendar.YEAR);\n+    int era = calendar.get(Calendar.ERA);\n+    int year = (era == GregorianCalendar.AD) ? yearOfEra : -(yearOfEra - 1);\n+    return new LocalDateTime(\n+        year,\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH),\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        calendar.get(Calendar.MILLISECOND)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDateTime.java",
        "method_name": "fromCalendarFields",
        "class_name": "LocalDateTime",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          195,
          210
        ],
        "original_code": "    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }\n"
      },
      {
        "hypothesis": "The bug arises because the method does not correctly handle years before the common era (BCE). When the calendar is set to BCE, the year should be adjusted accordingly by subtracting it from 1. This is because the GregorianCalendar uses positive numbers for years in both BCE and CE, but in BCE, the year 1 BCE corresponds to year 0 in astronomical year numbering, year 2 BCE to -1, etc.",
        "fixed_method": "public static LocalDateTime fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int year = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = 1 - year;\n    }\n    return new LocalDateTime(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH),\n        calendar.get(Calendar.HOUR_OF_DAY),\n        calendar.get(Calendar.MINUTE),\n        calendar.get(Calendar.SECOND),\n        calendar.get(Calendar.MILLISECOND)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,40 +1,18 @@\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n-     * This is useful if you have been using the Calendar as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method ignores the type of the calendar and always\n-     * creates a LocalDateTime with ISO chronology. It is expected that you\n-     * will only pass in instances of <code>GregorianCalendar</code> however\n-     * this is not validated.\n-     *\n-     * @param calendar  the Calendar to extract fields from, not null\n-     * @return the created local date-time, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n-        if (calendar == null) {\n-            throw new IllegalArgumentException(\"The calendar must not be null\");\n-        }\n-        int yearOfEra = calendar.get(Calendar.YEAR);\n-        return new LocalDateTime(\n-            yearOfEra,\n-            calendar.get(Calendar.MONTH) + 1,\n-            calendar.get(Calendar.DAY_OF_MONTH),\n-            calendar.get(Calendar.HOUR_OF_DAY),\n-            calendar.get(Calendar.MINUTE),\n-            calendar.get(Calendar.SECOND),\n-            calendar.get(Calendar.MILLISECOND)\n-        );\n+public static LocalDateTime fromCalendarFields(Calendar calendar) {\n+    if (calendar == null) {\n+        throw new IllegalArgumentException(\"The calendar must not be null\");\n     }\n+    int year = calendar.get(Calendar.YEAR);\n+    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        year = 1 - year;\n+    }\n+    return new LocalDateTime(\n+        year,\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH),\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        calendar.get(Calendar.MILLISECOND)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDateTime.java",
        "method_name": "fromCalendarFields",
        "class_name": "LocalDateTime",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          195,
          210
        ],
        "original_code": "    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }\n"
      },
      {
        "hypothesis": "The bug is due to the method not accounting for the BC era, which reverses the sign of the year and requires subtracting 1 since there is no year zero in Gregorian calendar. The year should be adjusted based on the era.",
        "fixed_method": "public static LocalDateTime fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int yearOfEra = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        yearOfEra = 1 - yearOfEra; // Adjust for BC years\n    }\n    return new LocalDateTime(\n        yearOfEra,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH),\n        calendar.get(Calendar.HOUR_OF_DAY),\n        calendar.get(Calendar.MINUTE),\n        calendar.get(Calendar.SECOND),\n        calendar.get(Calendar.MILLISECOND)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,40 +1,18 @@\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n-     * This is useful if you have been using the Calendar as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method ignores the type of the calendar and always\n-     * creates a LocalDateTime with ISO chronology. It is expected that you\n-     * will only pass in instances of <code>GregorianCalendar</code> however\n-     * this is not validated.\n-     *\n-     * @param calendar  the Calendar to extract fields from, not null\n-     * @return the created local date-time, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n-        if (calendar == null) {\n-            throw new IllegalArgumentException(\"The calendar must not be null\");\n-        }\n-        int yearOfEra = calendar.get(Calendar.YEAR);\n-        return new LocalDateTime(\n-            yearOfEra,\n-            calendar.get(Calendar.MONTH) + 1,\n-            calendar.get(Calendar.DAY_OF_MONTH),\n-            calendar.get(Calendar.HOUR_OF_DAY),\n-            calendar.get(Calendar.MINUTE),\n-            calendar.get(Calendar.SECOND),\n-            calendar.get(Calendar.MILLISECOND)\n-        );\n+public static LocalDateTime fromCalendarFields(Calendar calendar) {\n+    if (calendar == null) {\n+        throw new IllegalArgumentException(\"The calendar must not be null\");\n     }\n+    int yearOfEra = calendar.get(Calendar.YEAR);\n+    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        yearOfEra = 1 - yearOfEra; // Adjust for BC years\n+    }\n+    return new LocalDateTime(\n+        yearOfEra,\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH),\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        calendar.get(Calendar.MILLISECOND)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDateTime.java",
        "method_name": "fromCalendarFields",
        "class_name": "LocalDateTime",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          195,
          210
        ],
        "original_code": "    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }\n"
      },
      {
        "hypothesis": "The bug is due to not properly handling the BC (Before Christ) era in the GregorianCalendar when converting to LocalDateTime. In the BC era, the year should be converted to a negative value (or zero for 1 BC) when creating the LocalDateTime instance.",
        "fixed_method": "public static LocalDateTime fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int yearOfEra = calendar.get(Calendar.YEAR);\n    int era = calendar.get(Calendar.ERA);\n    if (era == GregorianCalendar.BC) {\n        yearOfEra = -(yearOfEra - 1);\n    }\n    return new LocalDateTime(\n        yearOfEra,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH),\n        calendar.get(Calendar.HOUR_OF_DAY),\n        calendar.get(Calendar.MINUTE),\n        calendar.get(Calendar.SECOND),\n        calendar.get(Calendar.MILLISECOND)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,40 +1,19 @@\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n-     * This is useful if you have been using the Calendar as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method ignores the type of the calendar and always\n-     * creates a LocalDateTime with ISO chronology. It is expected that you\n-     * will only pass in instances of <code>GregorianCalendar</code> however\n-     * this is not validated.\n-     *\n-     * @param calendar  the Calendar to extract fields from, not null\n-     * @return the created local date-time, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n-        if (calendar == null) {\n-            throw new IllegalArgumentException(\"The calendar must not be null\");\n-        }\n-        int yearOfEra = calendar.get(Calendar.YEAR);\n-        return new LocalDateTime(\n-            yearOfEra,\n-            calendar.get(Calendar.MONTH) + 1,\n-            calendar.get(Calendar.DAY_OF_MONTH),\n-            calendar.get(Calendar.HOUR_OF_DAY),\n-            calendar.get(Calendar.MINUTE),\n-            calendar.get(Calendar.SECOND),\n-            calendar.get(Calendar.MILLISECOND)\n-        );\n+public static LocalDateTime fromCalendarFields(Calendar calendar) {\n+    if (calendar == null) {\n+        throw new IllegalArgumentException(\"The calendar must not be null\");\n     }\n+    int yearOfEra = calendar.get(Calendar.YEAR);\n+    int era = calendar.get(Calendar.ERA);\n+    if (era == GregorianCalendar.BC) {\n+        yearOfEra = -(yearOfEra - 1);\n+    }\n+    return new LocalDateTime(\n+        yearOfEra,\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH),\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        calendar.get(Calendar.MILLISECOND)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDateTime.java",
        "method_name": "fromCalendarFields",
        "class_name": "LocalDateTime",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          195,
          210
        ],
        "original_code": "    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }\n"
      }
    ],
    [
      {
        "hypothesis": "The bug is caused by the method not correctly handling dates in the BC era. The Java Date class represents years as positive numbers regardless of era, so manual adjustment is needed to convert BC years to negative year values as used by the LocalDate class. Specifically, for BC dates, the year should be negated and then decremented by one to account for the absence of a year zero in the AD/BC system.",
        "fixed_method": "public static LocalDate fromDateFields(Date date) {\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    int year = date.getYear() + 1900;\n    int month = date.getMonth() + 1;\n    int day = date.getDate();\n    \n    // Check if the date is in BC era\n    GregorianCalendar cal = new GregorianCalendar();\n    cal.setTime(date);\n    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = -(year - 1);\n    }\n    \n    return new LocalDate(year, month, day);\n}",
        "diff": "--- original\n+++ changed\n@@ -1,33 +1,17 @@\n-    /**\n-     * Constructs a LocalDate from a <code>java.util.Date</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Date and assigned to the LocalDate.\n-     * This is useful if you have been using the Date as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method always creates a LocalDate with ISO chronology.\n-     *\n-     * @param date  the Date to extract fields from, not null\n-     * @return the created local date, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    @SuppressWarnings(\"deprecation\")\n-    public static LocalDate fromDateFields(Date date) {\n-        if (date == null) {\n-            throw new IllegalArgumentException(\"The date must not be null\");\n-        }\n-            // handle years in era BC\n-        return new LocalDate(\n-            date.getYear() + 1900,\n-            date.getMonth() + 1,\n-            date.getDate()\n-        );\n+public static LocalDate fromDateFields(Date date) {\n+    if (date == null) {\n+        throw new IllegalArgumentException(\"The date must not be null\");\n     }\n+    int year = date.getYear() + 1900;\n+    int month = date.getMonth() + 1;\n+    int day = date.getDate();\n+    \n+    // Check if the date is in BC era\n+    GregorianCalendar cal = new GregorianCalendar();\n+    cal.setTime(date);\n+    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        year = -(year - 1);\n+    }\n+    \n+    return new LocalDate(year, month, day);\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDate.java",
        "method_name": "fromDateFields",
        "class_name": "LocalDate",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          238,
          250
        ],
        "original_code": "    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }\n"
      },
      {
        "hypothesis": "The bug is due to the incorrect handling of BC (Before Christ) years. The current implementation does not account for the GregorianCalendar's era setting, which can designate years as BC. When the era is BC, the year should be negated and adjusted by subtracting one, because the year 1 BC is represented as year 0 in astronomical year numbering, 2 BC as -1, and so forth.",
        "fixed_method": "public static LocalDate fromDateFields(Date date) {\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    GregorianCalendar cal = new GregorianCalendar();\n    cal.setTime(date);\n    int year = cal.get(Calendar.YEAR);\n    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = -(year - 1); // Adjust year for BC\n    }\n    return new LocalDate(\n        year,\n        cal.get(Calendar.MONTH) + 1,\n        cal.get(Calendar.DAY_OF_MONTH)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,33 +1,16 @@\n-    /**\n-     * Constructs a LocalDate from a <code>java.util.Date</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Date and assigned to the LocalDate.\n-     * This is useful if you have been using the Date as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method always creates a LocalDate with ISO chronology.\n-     *\n-     * @param date  the Date to extract fields from, not null\n-     * @return the created local date, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    @SuppressWarnings(\"deprecation\")\n-    public static LocalDate fromDateFields(Date date) {\n-        if (date == null) {\n-            throw new IllegalArgumentException(\"The date must not be null\");\n-        }\n-            // handle years in era BC\n-        return new LocalDate(\n-            date.getYear() + 1900,\n-            date.getMonth() + 1,\n-            date.getDate()\n-        );\n+public static LocalDate fromDateFields(Date date) {\n+    if (date == null) {\n+        throw new IllegalArgumentException(\"The date must not be null\");\n     }\n+    GregorianCalendar cal = new GregorianCalendar();\n+    cal.setTime(date);\n+    int year = cal.get(Calendar.YEAR);\n+    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        year = -(year - 1); // Adjust year for BC\n+    }\n+    return new LocalDate(\n+        year,\n+        cal.get(Calendar.MONTH) + 1,\n+        cal.get(Calendar.DAY_OF_MONTH)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDate.java",
        "method_name": "fromDateFields",
        "class_name": "LocalDate",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          238,
          250
        ],
        "original_code": "    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }\n"
      },
      {
        "hypothesis": "The bug is in handling dates before the common era (BC). The method is using the year directly from the Date object, which does not account for the ERA field in GregorianCalendar. When the year is before the common era (BC), the year should be negated and offset by 1 to reflect the correct year in the LocalDate. This is because GregorianCalendar represents the year before 1 AD as 1 BC, which should be represented as year 0 in LocalDate, and subsequently, 2 BC should be represented as -1, and so on.",
        "fixed_method": "public static LocalDate fromDateFields(Date date) {\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    int year = date.getYear() + 1900;\n    int month = date.getMonth() + 1;\n    int day = date.getDate();\n    GregorianCalendar cal = new GregorianCalendar();\n    cal.setTime(date);\n    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = -(year - 1);\n    }\n    return new LocalDate(year, month, day);\n}",
        "diff": "--- original\n+++ changed\n@@ -1,33 +1,14 @@\n-    /**\n-     * Constructs a LocalDate from a <code>java.util.Date</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Date and assigned to the LocalDate.\n-     * This is useful if you have been using the Date as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method always creates a LocalDate with ISO chronology.\n-     *\n-     * @param date  the Date to extract fields from, not null\n-     * @return the created local date, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    @SuppressWarnings(\"deprecation\")\n-    public static LocalDate fromDateFields(Date date) {\n-        if (date == null) {\n-            throw new IllegalArgumentException(\"The date must not be null\");\n-        }\n-            // handle years in era BC\n-        return new LocalDate(\n-            date.getYear() + 1900,\n-            date.getMonth() + 1,\n-            date.getDate()\n-        );\n+public static LocalDate fromDateFields(Date date) {\n+    if (date == null) {\n+        throw new IllegalArgumentException(\"The date must not be null\");\n     }\n+    int year = date.getYear() + 1900;\n+    int month = date.getMonth() + 1;\n+    int day = date.getDate();\n+    GregorianCalendar cal = new GregorianCalendar();\n+    cal.setTime(date);\n+    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        year = -(year - 1);\n+    }\n+    return new LocalDate(year, month, day);\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDate.java",
        "method_name": "fromDateFields",
        "class_name": "LocalDate",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          238,
          250
        ],
        "original_code": "    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }\n"
      },
      {
        "hypothesis": "The bug is due to the incorrect handling of years in the BC era. The `java.util.Date` class does not provide direct support for years before 1 AD, and the conversion from BC to AD needs to be handled manually. Specifically, in the Gregorian calendar, the year 1 BC is equivalent to year 0 in astronomical year numbering, and 2 BC is equivalent to year -1, and so on. The current method does not account for this and simply adds 1900 to the year, which is incorrect for BC years.",
        "fixed_method": "public static LocalDate fromDateFields(Date date) {\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    GregorianCalendar cal = new GregorianCalendar();\n    cal.setTime(date);\n    int year = cal.get(Calendar.YEAR);\n    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = -(year - 1); // Convert BC year to astronomical year\n    }\n    return new LocalDate(\n        year,\n        cal.get(Calendar.MONTH) + 1,\n        cal.get(Calendar.DAY_OF_MONTH)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,33 +1,16 @@\n-    /**\n-     * Constructs a LocalDate from a <code>java.util.Date</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Date and assigned to the LocalDate.\n-     * This is useful if you have been using the Date as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method always creates a LocalDate with ISO chronology.\n-     *\n-     * @param date  the Date to extract fields from, not null\n-     * @return the created local date, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    @SuppressWarnings(\"deprecation\")\n-    public static LocalDate fromDateFields(Date date) {\n-        if (date == null) {\n-            throw new IllegalArgumentException(\"The date must not be null\");\n-        }\n-            // handle years in era BC\n-        return new LocalDate(\n-            date.getYear() + 1900,\n-            date.getMonth() + 1,\n-            date.getDate()\n-        );\n+public static LocalDate fromDateFields(Date date) {\n+    if (date == null) {\n+        throw new IllegalArgumentException(\"The date must not be null\");\n     }\n+    GregorianCalendar cal = new GregorianCalendar();\n+    cal.setTime(date);\n+    int year = cal.get(Calendar.YEAR);\n+    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        year = -(year - 1); // Convert BC year to astronomical year\n+    }\n+    return new LocalDate(\n+        year,\n+        cal.get(Calendar.MONTH) + 1,\n+        cal.get(Calendar.DAY_OF_MONTH)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDate.java",
        "method_name": "fromDateFields",
        "class_name": "LocalDate",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          238,
          250
        ],
        "original_code": "    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }\n"
      },
      {
        "hypothesis": "The bug is due to the method not handling dates in the BC era correctly. The year conversion logic is incorrect for BC dates. The method should subtract the year from 1 for BC dates to convert correctly to the LocalDate format, which represents BC years as negative values.",
        "fixed_method": "    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        // Use Calendar to determine if the date is in the BC era\n        Calendar cal = Calendar.getInstance();\n        cal.setTime(date);\n        int year = date.getYear() + 1900;\n        int month = date.getMonth() + 1;\n        int day = date.getDate();\n\n        // Check if the date is in BC\n        if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n            year = 1 - year; // Convert to negative year for BC\n        }\n\n        return new LocalDate(year, month, day);\n    }",
        "diff": "--- original\n+++ changed\n@@ -1,33 +1,19 @@\n-    /**\n-     * Constructs a LocalDate from a <code>java.util.Date</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Date and assigned to the LocalDate.\n-     * This is useful if you have been using the Date as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method always creates a LocalDate with ISO chronology.\n-     *\n-     * @param date  the Date to extract fields from, not null\n-     * @return the created local date, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n     @SuppressWarnings(\"deprecation\")\n     public static LocalDate fromDateFields(Date date) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n-            // handle years in era BC\n-        return new LocalDate(\n-            date.getYear() + 1900,\n-            date.getMonth() + 1,\n-            date.getDate()\n-        );\n-    }\n+        // Use Calendar to determine if the date is in the BC era\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(date);\n+        int year = date.getYear() + 1900;\n+        int month = date.getMonth() + 1;\n+        int day = date.getDate();\n+\n+        // Check if the date is in BC\n+        if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n+            year = 1 - year; // Convert to negative year for BC\n+        }\n+\n+        return new LocalDate(year, month, day);\n+    }",
        "file_path": "src/main/java/org/joda/time/LocalDate.java",
        "method_name": "fromDateFields",
        "class_name": "LocalDate",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          238,
          250
        ],
        "original_code": "    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }\n"
      },
      {
        "hypothesis": "The bug lies in the handling of dates before the Common Era (BCE) as Java's Date class doesn't directly support BCE dates. The method incorrectly assumes all years are CE by adding 1900 to the year obtained from the Date object. When dealing with BCE (BC) years, we need to adjust the calculation to correctly handle the era and reflect the correct negative year values.",
        "fixed_method": "public static LocalDate fromDateFields(Date date) {\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    // Create a calendar instance to check the era\n    GregorianCalendar cal = new GregorianCalendar();\n    cal.setTime(date);\n    int year = date.getYear() + 1900;\n    // Adjust for BC era\n    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = -(year - 1);\n    }\n    return new LocalDate(\n        year,\n        date.getMonth() + 1,\n        date.getDate()\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,33 +1,18 @@\n-    /**\n-     * Constructs a LocalDate from a <code>java.util.Date</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Date and assigned to the LocalDate.\n-     * This is useful if you have been using the Date as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method always creates a LocalDate with ISO chronology.\n-     *\n-     * @param date  the Date to extract fields from, not null\n-     * @return the created local date, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    @SuppressWarnings(\"deprecation\")\n-    public static LocalDate fromDateFields(Date date) {\n-        if (date == null) {\n-            throw new IllegalArgumentException(\"The date must not be null\");\n-        }\n-            // handle years in era BC\n-        return new LocalDate(\n-            date.getYear() + 1900,\n-            date.getMonth() + 1,\n-            date.getDate()\n-        );\n+public static LocalDate fromDateFields(Date date) {\n+    if (date == null) {\n+        throw new IllegalArgumentException(\"The date must not be null\");\n     }\n+    // Create a calendar instance to check the era\n+    GregorianCalendar cal = new GregorianCalendar();\n+    cal.setTime(date);\n+    int year = date.getYear() + 1900;\n+    // Adjust for BC era\n+    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        year = -(year - 1);\n+    }\n+    return new LocalDate(\n+        year,\n+        date.getMonth() + 1,\n+        date.getDate()\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDate.java",
        "method_name": "fromDateFields",
        "class_name": "LocalDate",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          238,
          250
        ],
        "original_code": "    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }\n"
      },
      {
        "hypothesis": "The issue arises from the incorrect handling of BC (Before Christ) dates. The Java Date API does not directly account for BC dates, so when we retrieve the year value, it returns a positive number for BC years. We need to adjust the year conversion to correctly handle BC dates by converting the year to a negative value when the era is BC.",
        "fixed_method": "public static LocalDate fromDateFields(Date date) {\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    GregorianCalendar cal = new GregorianCalendar();\n    cal.setTime(date);\n    int year = cal.get(Calendar.YEAR);\n    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = -(year - 1);\n    }\n    return new LocalDate(\n        year,\n        cal.get(Calendar.MONTH) + 1,\n        cal.get(Calendar.DAY_OF_MONTH)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,33 +1,16 @@\n-    /**\n-     * Constructs a LocalDate from a <code>java.util.Date</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Date and assigned to the LocalDate.\n-     * This is useful if you have been using the Date as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method always creates a LocalDate with ISO chronology.\n-     *\n-     * @param date  the Date to extract fields from, not null\n-     * @return the created local date, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    @SuppressWarnings(\"deprecation\")\n-    public static LocalDate fromDateFields(Date date) {\n-        if (date == null) {\n-            throw new IllegalArgumentException(\"The date must not be null\");\n-        }\n-            // handle years in era BC\n-        return new LocalDate(\n-            date.getYear() + 1900,\n-            date.getMonth() + 1,\n-            date.getDate()\n-        );\n+public static LocalDate fromDateFields(Date date) {\n+    if (date == null) {\n+        throw new IllegalArgumentException(\"The date must not be null\");\n     }\n+    GregorianCalendar cal = new GregorianCalendar();\n+    cal.setTime(date);\n+    int year = cal.get(Calendar.YEAR);\n+    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        year = -(year - 1);\n+    }\n+    return new LocalDate(\n+        year,\n+        cal.get(Calendar.MONTH) + 1,\n+        cal.get(Calendar.DAY_OF_MONTH)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDate.java",
        "method_name": "fromDateFields",
        "class_name": "LocalDate",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          238,
          250
        ],
        "original_code": "    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }\n"
      },
      {
        "hypothesis": "The bug arises because the conversion from Date to LocalDate does not consider the era (BC/AD) of the year. The method assumes the year is always AD, which is incorrect for dates in the BC era. To fix this, we need to adjust the year based on the era: if the date is in the BC era, the year should be negative and reduced by 1 since there is no year zero.",
        "fixed_method": "public static LocalDate fromDateFields(Date date) {\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    GregorianCalendar cal = new GregorianCalendar();\n    cal.setTime(date);\n\n    int year = cal.get(Calendar.YEAR);\n    int month = cal.get(Calendar.MONTH) + 1; // Calendar.MONTH is zero-based\n    int day = cal.get(Calendar.DAY_OF_MONTH);\n\n    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = -(year - 1); // Convert to BC year, adjusting for lack of year zero\n    }\n\n    return new LocalDate(year, month, day);\n}",
        "diff": "--- original\n+++ changed\n@@ -1,33 +1,17 @@\n-    /**\n-     * Constructs a LocalDate from a <code>java.util.Date</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Date and assigned to the LocalDate.\n-     * This is useful if you have been using the Date as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method always creates a LocalDate with ISO chronology.\n-     *\n-     * @param date  the Date to extract fields from, not null\n-     * @return the created local date, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n+public static LocalDate fromDateFields(Date date) {\n+    if (date == null) {\n+        throw new IllegalArgumentException(\"The date must not be null\");\n+    }\n+    GregorianCalendar cal = new GregorianCalendar();\n+    cal.setTime(date);\n \n-    @SuppressWarnings(\"deprecation\")\n-    public static LocalDate fromDateFields(Date date) {\n-        if (date == null) {\n-            throw new IllegalArgumentException(\"The date must not be null\");\n-        }\n-            // handle years in era BC\n-        return new LocalDate(\n-            date.getYear() + 1900,\n-            date.getMonth() + 1,\n-            date.getDate()\n-        );\n+    int year = cal.get(Calendar.YEAR);\n+    int month = cal.get(Calendar.MONTH) + 1; // Calendar.MONTH is zero-based\n+    int day = cal.get(Calendar.DAY_OF_MONTH);\n+\n+    if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        year = -(year - 1); // Convert to BC year, adjusting for lack of year zero\n     }\n+\n+    return new LocalDate(year, month, day);\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDate.java",
        "method_name": "fromDateFields",
        "class_name": "LocalDate",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          238,
          250
        ],
        "original_code": "    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }\n"
      }
    ],
    [
      {
        "hypothesis": "The issue arises because the method does not account for the BC (Before Christ) era when converting the year. The year in BC should be negated to reflect the correct year in the LocalDate object. In the Gregorian calendar, year 1 BC is represented as year 0, 2 BC as -1, and so on. The code should adjust the year accordingly based on the ERA field of the calendar.",
        "fixed_method": "public static LocalDate fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int year = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = -(year - 1);\n    }\n    return new LocalDate(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,36 +1,14 @@\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Calendar and assigned to the LocalDate.\n-     * This is useful if you have been using the Calendar as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method ignores the type of the calendar and always\n-     * creates a LocalDate with ISO chronology. It is expected that you\n-     * will only pass in instances of <code>GregorianCalendar</code> however\n-     * this is not validated.\n-     *\n-     * @param calendar  the Calendar to extract fields from, not null\n-     * @return the created local date, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    public static LocalDate fromCalendarFields(Calendar calendar) {\n-        if (calendar == null) {\n-            throw new IllegalArgumentException(\"The calendar must not be null\");\n-        }\n-        int yearOfEra = calendar.get(Calendar.YEAR);\n-        return new LocalDate(\n-            yearOfEra,\n-            calendar.get(Calendar.MONTH) + 1,\n-            calendar.get(Calendar.DAY_OF_MONTH)\n-        );\n+public static LocalDate fromCalendarFields(Calendar calendar) {\n+    if (calendar == null) {\n+        throw new IllegalArgumentException(\"The calendar must not be null\");\n     }\n+    int year = calendar.get(Calendar.YEAR);\n+    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        year = -(year - 1);\n+    }\n+    return new LocalDate(\n+        year,\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDate.java",
        "method_name": "fromCalendarFields",
        "class_name": "LocalDate",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          206,
          217
        ],
        "original_code": "    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }\n"
      },
      {
        "hypothesis": "The issue arises when handling dates before the common era (BCE). The code does not correctly adjust the year for BCE dates as it directly uses the 'YEAR' field without considering the 'ERA'. In the Gregorian calendar system, BCE years are represented as negative, with year 1 BCE being 0 in Java's GregorianCalendar. Therefore, the calculation for the year needs to be adjusted based on the era.",
        "fixed_method": "public static LocalDate fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int era = calendar.get(Calendar.ERA);\n    int year = calendar.get(Calendar.YEAR);\n    if (era == GregorianCalendar.BC) {\n        year = -(year - 1);\n    }\n    return new LocalDate(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,36 +1,15 @@\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Calendar and assigned to the LocalDate.\n-     * This is useful if you have been using the Calendar as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method ignores the type of the calendar and always\n-     * creates a LocalDate with ISO chronology. It is expected that you\n-     * will only pass in instances of <code>GregorianCalendar</code> however\n-     * this is not validated.\n-     *\n-     * @param calendar  the Calendar to extract fields from, not null\n-     * @return the created local date, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    public static LocalDate fromCalendarFields(Calendar calendar) {\n-        if (calendar == null) {\n-            throw new IllegalArgumentException(\"The calendar must not be null\");\n-        }\n-        int yearOfEra = calendar.get(Calendar.YEAR);\n-        return new LocalDate(\n-            yearOfEra,\n-            calendar.get(Calendar.MONTH) + 1,\n-            calendar.get(Calendar.DAY_OF_MONTH)\n-        );\n+public static LocalDate fromCalendarFields(Calendar calendar) {\n+    if (calendar == null) {\n+        throw new IllegalArgumentException(\"The calendar must not be null\");\n     }\n+    int era = calendar.get(Calendar.ERA);\n+    int year = calendar.get(Calendar.YEAR);\n+    if (era == GregorianCalendar.BC) {\n+        year = -(year - 1);\n+    }\n+    return new LocalDate(\n+        year,\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDate.java",
        "method_name": "fromCalendarFields",
        "class_name": "LocalDate",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          206,
          217
        ],
        "original_code": "    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }\n"
      },
      {
        "hypothesis": "The bug is caused by not considering the era when converting from a Calendar to LocalDate. When the era is BC, the year value should be adjusted by multiplying it by -1 and subtracting 1 to match the LocalDate representation of years before the Common Era (BCE).",
        "fixed_method": "public static LocalDate fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int year = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = -(year - 1);\n    }\n    return new LocalDate(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,36 +1,14 @@\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Calendar and assigned to the LocalDate.\n-     * This is useful if you have been using the Calendar as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method ignores the type of the calendar and always\n-     * creates a LocalDate with ISO chronology. It is expected that you\n-     * will only pass in instances of <code>GregorianCalendar</code> however\n-     * this is not validated.\n-     *\n-     * @param calendar  the Calendar to extract fields from, not null\n-     * @return the created local date, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    public static LocalDate fromCalendarFields(Calendar calendar) {\n-        if (calendar == null) {\n-            throw new IllegalArgumentException(\"The calendar must not be null\");\n-        }\n-        int yearOfEra = calendar.get(Calendar.YEAR);\n-        return new LocalDate(\n-            yearOfEra,\n-            calendar.get(Calendar.MONTH) + 1,\n-            calendar.get(Calendar.DAY_OF_MONTH)\n-        );\n+public static LocalDate fromCalendarFields(Calendar calendar) {\n+    if (calendar == null) {\n+        throw new IllegalArgumentException(\"The calendar must not be null\");\n     }\n+    int year = calendar.get(Calendar.YEAR);\n+    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        year = -(year - 1);\n+    }\n+    return new LocalDate(\n+        year,\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDate.java",
        "method_name": "fromCalendarFields",
        "class_name": "LocalDate",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          206,
          217
        ],
        "original_code": "    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }\n"
      },
      {
        "hypothesis": "The bug is caused by not handling the BC era in the GregorianCalendar, leading to incorrect year values. The method needs to adjust the year according to the era: if it's BC, the year should be negated and decremented by 1 to account for the absence of year zero in the Gregorian calendar.",
        "fixed_method": "public static LocalDate fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int yearOfEra = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        yearOfEra = -(yearOfEra - 1);  // Adjust for BC era\n    }\n    return new LocalDate(\n        yearOfEra,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,36 +1,14 @@\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Calendar and assigned to the LocalDate.\n-     * This is useful if you have been using the Calendar as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method ignores the type of the calendar and always\n-     * creates a LocalDate with ISO chronology. It is expected that you\n-     * will only pass in instances of <code>GregorianCalendar</code> however\n-     * this is not validated.\n-     *\n-     * @param calendar  the Calendar to extract fields from, not null\n-     * @return the created local date, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    public static LocalDate fromCalendarFields(Calendar calendar) {\n-        if (calendar == null) {\n-            throw new IllegalArgumentException(\"The calendar must not be null\");\n-        }\n-        int yearOfEra = calendar.get(Calendar.YEAR);\n-        return new LocalDate(\n-            yearOfEra,\n-            calendar.get(Calendar.MONTH) + 1,\n-            calendar.get(Calendar.DAY_OF_MONTH)\n-        );\n+public static LocalDate fromCalendarFields(Calendar calendar) {\n+    if (calendar == null) {\n+        throw new IllegalArgumentException(\"The calendar must not be null\");\n     }\n+    int yearOfEra = calendar.get(Calendar.YEAR);\n+    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        yearOfEra = -(yearOfEra - 1);  // Adjust for BC era\n+    }\n+    return new LocalDate(\n+        yearOfEra,\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDate.java",
        "method_name": "fromCalendarFields",
        "class_name": "LocalDate",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          206,
          217
        ],
        "original_code": "    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }\n"
      },
      {
        "hypothesis": "The bug is that the code does not correctly handle years in the BC era. The method only considers the year and does not account for the ERA field, which results in incorrect year calculations when the year is before year zero. The fix involves adjusting the year based on the ERA field: for BC, the year should be negated and decremented by 1 because there is no year zero in the ISO chronology.",
        "fixed_method": "public static LocalDate fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int year = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = -(year - 1); // Adjust for BC era\n    }\n    return new LocalDate(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,36 +1,14 @@\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Calendar and assigned to the LocalDate.\n-     * This is useful if you have been using the Calendar as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method ignores the type of the calendar and always\n-     * creates a LocalDate with ISO chronology. It is expected that you\n-     * will only pass in instances of <code>GregorianCalendar</code> however\n-     * this is not validated.\n-     *\n-     * @param calendar  the Calendar to extract fields from, not null\n-     * @return the created local date, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    public static LocalDate fromCalendarFields(Calendar calendar) {\n-        if (calendar == null) {\n-            throw new IllegalArgumentException(\"The calendar must not be null\");\n-        }\n-        int yearOfEra = calendar.get(Calendar.YEAR);\n-        return new LocalDate(\n-            yearOfEra,\n-            calendar.get(Calendar.MONTH) + 1,\n-            calendar.get(Calendar.DAY_OF_MONTH)\n-        );\n+public static LocalDate fromCalendarFields(Calendar calendar) {\n+    if (calendar == null) {\n+        throw new IllegalArgumentException(\"The calendar must not be null\");\n     }\n+    int year = calendar.get(Calendar.YEAR);\n+    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        year = -(year - 1); // Adjust for BC era\n+    }\n+    return new LocalDate(\n+        year,\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDate.java",
        "method_name": "fromCalendarFields",
        "class_name": "LocalDate",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          206,
          217
        ],
        "original_code": "    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }\n"
      },
      {
        "hypothesis": "The bug is due to not taking into account the BC era when extracting the year from the Calendar object. The calendar year needs to be adjusted to reflect negative years for BC dates. In the Gregorian calendar, 1 BC is represented as year 0, 2 BC as -1, and so on. The method should adjust the year based on the era.",
        "fixed_method": "public static LocalDate fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int year = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = 1 - year; // Adjust the year to represent BC dates correctly\n    }\n    return new LocalDate(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,36 +1,14 @@\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Calendar and assigned to the LocalDate.\n-     * This is useful if you have been using the Calendar as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method ignores the type of the calendar and always\n-     * creates a LocalDate with ISO chronology. It is expected that you\n-     * will only pass in instances of <code>GregorianCalendar</code> however\n-     * this is not validated.\n-     *\n-     * @param calendar  the Calendar to extract fields from, not null\n-     * @return the created local date, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    public static LocalDate fromCalendarFields(Calendar calendar) {\n-        if (calendar == null) {\n-            throw new IllegalArgumentException(\"The calendar must not be null\");\n-        }\n-        int yearOfEra = calendar.get(Calendar.YEAR);\n-        return new LocalDate(\n-            yearOfEra,\n-            calendar.get(Calendar.MONTH) + 1,\n-            calendar.get(Calendar.DAY_OF_MONTH)\n-        );\n+public static LocalDate fromCalendarFields(Calendar calendar) {\n+    if (calendar == null) {\n+        throw new IllegalArgumentException(\"The calendar must not be null\");\n     }\n+    int year = calendar.get(Calendar.YEAR);\n+    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        year = 1 - year; // Adjust the year to represent BC dates correctly\n+    }\n+    return new LocalDate(\n+        year,\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDate.java",
        "method_name": "fromCalendarFields",
        "class_name": "LocalDate",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          206,
          217
        ],
        "original_code": "    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }\n"
      },
      {
        "hypothesis": "The bug is related to the handling of year values before the common era (BC). The original method does not account for the ERA field, leading to incorrect year calculations when the era is BC. We need to adjust the year calculation by converting the year to a negative value when the calendar is set to BC.",
        "fixed_method": "public static LocalDate fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int yearOfEra = calendar.get(Calendar.YEAR);\n    int era = calendar.get(Calendar.ERA);\n    int year = (era == GregorianCalendar.BC) ? -(yearOfEra - 1) : yearOfEra;\n    return new LocalDate(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,36 +1,13 @@\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Calendar and assigned to the LocalDate.\n-     * This is useful if you have been using the Calendar as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method ignores the type of the calendar and always\n-     * creates a LocalDate with ISO chronology. It is expected that you\n-     * will only pass in instances of <code>GregorianCalendar</code> however\n-     * this is not validated.\n-     *\n-     * @param calendar  the Calendar to extract fields from, not null\n-     * @return the created local date, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    public static LocalDate fromCalendarFields(Calendar calendar) {\n-        if (calendar == null) {\n-            throw new IllegalArgumentException(\"The calendar must not be null\");\n-        }\n-        int yearOfEra = calendar.get(Calendar.YEAR);\n-        return new LocalDate(\n-            yearOfEra,\n-            calendar.get(Calendar.MONTH) + 1,\n-            calendar.get(Calendar.DAY_OF_MONTH)\n-        );\n+public static LocalDate fromCalendarFields(Calendar calendar) {\n+    if (calendar == null) {\n+        throw new IllegalArgumentException(\"The calendar must not be null\");\n     }\n+    int yearOfEra = calendar.get(Calendar.YEAR);\n+    int era = calendar.get(Calendar.ERA);\n+    int year = (era == GregorianCalendar.BC) ? -(yearOfEra - 1) : yearOfEra;\n+    return new LocalDate(\n+        year,\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDate.java",
        "method_name": "fromCalendarFields",
        "class_name": "LocalDate",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          206,
          217
        ],
        "original_code": "    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }\n"
      },
      {
        "hypothesis": "The bug is caused by not correctly handling years in the BC era. The Gregorian calendar uses a different numbering scheme for BC (BCE) years: year 1 BC is represented as year 1, year 2 BC as year 2, etc. The code does not account for the BC era, causing incorrect year values for BC dates. The fix involves adjusting the year value based on the era.",
        "fixed_method": "public static LocalDate fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int yearOfEra = calendar.get(Calendar.YEAR);\n    int era = calendar.get(Calendar.ERA);\n    // If the era is BC, convert the year to negative\n    int year = (era == GregorianCalendar.BC) ? -(yearOfEra - 1) : yearOfEra;\n    return new LocalDate(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,36 +1,14 @@\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Calendar and assigned to the LocalDate.\n-     * This is useful if you have been using the Calendar as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method ignores the type of the calendar and always\n-     * creates a LocalDate with ISO chronology. It is expected that you\n-     * will only pass in instances of <code>GregorianCalendar</code> however\n-     * this is not validated.\n-     *\n-     * @param calendar  the Calendar to extract fields from, not null\n-     * @return the created local date, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    public static LocalDate fromCalendarFields(Calendar calendar) {\n-        if (calendar == null) {\n-            throw new IllegalArgumentException(\"The calendar must not be null\");\n-        }\n-        int yearOfEra = calendar.get(Calendar.YEAR);\n-        return new LocalDate(\n-            yearOfEra,\n-            calendar.get(Calendar.MONTH) + 1,\n-            calendar.get(Calendar.DAY_OF_MONTH)\n-        );\n+public static LocalDate fromCalendarFields(Calendar calendar) {\n+    if (calendar == null) {\n+        throw new IllegalArgumentException(\"The calendar must not be null\");\n     }\n+    int yearOfEra = calendar.get(Calendar.YEAR);\n+    int era = calendar.get(Calendar.ERA);\n+    // If the era is BC, convert the year to negative\n+    int year = (era == GregorianCalendar.BC) ? -(yearOfEra - 1) : yearOfEra;\n+    return new LocalDate(\n+        year,\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDate.java",
        "method_name": "fromCalendarFields",
        "class_name": "LocalDate",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          206,
          217
        ],
        "original_code": "    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }\n"
      },
      {
        "hypothesis": "The issue lies in the handling of years in the BC era. The current implementation does not account for the BC era, so it treats the year as an AD year. The fix involves checking if the calendar is in the BC era and adjusting the year accordingly by negating it and subtracting 1, as years in the BC era are represented with negative values in Joda-Time, and there is no year '0'.",
        "fixed_method": "public static LocalDate fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int yearOfEra = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        yearOfEra = -(yearOfEra - 1);\n    }\n    return new LocalDate(\n        yearOfEra,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,36 +1,14 @@\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Calendar and assigned to the LocalDate.\n-     * This is useful if you have been using the Calendar as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method ignores the type of the calendar and always\n-     * creates a LocalDate with ISO chronology. It is expected that you\n-     * will only pass in instances of <code>GregorianCalendar</code> however\n-     * this is not validated.\n-     *\n-     * @param calendar  the Calendar to extract fields from, not null\n-     * @return the created local date, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    public static LocalDate fromCalendarFields(Calendar calendar) {\n-        if (calendar == null) {\n-            throw new IllegalArgumentException(\"The calendar must not be null\");\n-        }\n-        int yearOfEra = calendar.get(Calendar.YEAR);\n-        return new LocalDate(\n-            yearOfEra,\n-            calendar.get(Calendar.MONTH) + 1,\n-            calendar.get(Calendar.DAY_OF_MONTH)\n-        );\n+public static LocalDate fromCalendarFields(Calendar calendar) {\n+    if (calendar == null) {\n+        throw new IllegalArgumentException(\"The calendar must not be null\");\n     }\n+    int yearOfEra = calendar.get(Calendar.YEAR);\n+    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        yearOfEra = -(yearOfEra - 1);\n+    }\n+    return new LocalDate(\n+        yearOfEra,\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDate.java",
        "method_name": "fromCalendarFields",
        "class_name": "LocalDate",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          206,
          217
        ],
        "original_code": "    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }\n"
      },
      {
        "hypothesis": "The bug is due to the method not handling the BC era correctly. The year should be negated and decremented by 1 for BC dates because the GregorianCalendar represents years before AD 1 as 1, 2, 3, etc., but LocalDate expects them as 0, -1, -2, etc.",
        "fixed_method": "public static LocalDate fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int year = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = -(year - 1);\n    }\n    return new LocalDate(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH)\n    );\n}",
        "diff": "--- original\n+++ changed\n@@ -1,36 +1,14 @@\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n-     * using exactly the same field values.\n-     * <p>\n-     * Each field is queried from the Calendar and assigned to the LocalDate.\n-     * This is useful if you have been using the Calendar as a local date,\n-     * ignoring the zone.\n-     * <p>\n-     * One advantage of this method is that this method is unaffected if the\n-     * version of the time zone data differs between the JDK and Joda-Time.\n-     * That is because the local field values are transferred, calculated using\n-     * the JDK time zone data and without using the Joda-Time time zone data.\n-     * <p>\n-     * This factory method ignores the type of the calendar and always\n-     * creates a LocalDate with ISO chronology. It is expected that you\n-     * will only pass in instances of <code>GregorianCalendar</code> however\n-     * this is not validated.\n-     *\n-     * @param calendar  the Calendar to extract fields from, not null\n-     * @return the created local date, not null\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n-     */\n-\n-    public static LocalDate fromCalendarFields(Calendar calendar) {\n-        if (calendar == null) {\n-            throw new IllegalArgumentException(\"The calendar must not be null\");\n-        }\n-        int yearOfEra = calendar.get(Calendar.YEAR);\n-        return new LocalDate(\n-            yearOfEra,\n-            calendar.get(Calendar.MONTH) + 1,\n-            calendar.get(Calendar.DAY_OF_MONTH)\n-        );\n+public static LocalDate fromCalendarFields(Calendar calendar) {\n+    if (calendar == null) {\n+        throw new IllegalArgumentException(\"The calendar must not be null\");\n     }\n+    int year = calendar.get(Calendar.YEAR);\n+    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n+        year = -(year - 1);\n+    }\n+    return new LocalDate(\n+        year,\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH)\n+    );\n+}",
        "file_path": "src/main/java/org/joda/time/LocalDate.java",
        "method_name": "fromCalendarFields",
        "class_name": "LocalDate",
        "iteration": 1,
        "is_multi_method": false,
        "line_numbers": [
          206,
          217
        ],
        "original_code": "    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }\n"
      }
    ]
  ],
  "iterations": 4,
  "monitor_file": "traces/Time-12_trace.json"
}