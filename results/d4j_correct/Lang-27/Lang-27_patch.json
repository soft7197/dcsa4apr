{
    "bug_id": "Lang-27",
    "success": true,
    "error": null,
    "patch": null,
    "project_path": "/tmp/d4j_Lang-27_1756863431",
    "patches": [
        {
            "hypothesis": "The error occurs because the calculation of expPos is incorrect. It uses the sum of the indices of 'e' and 'E', which results in an incorrect value when both are not present. This leads to a StringIndexOutOfBoundsException when trying to extract the mantissa. The fix involves correctly calculating expPos by checking for the presence of 'e' or 'E' and using the correct index.",
            "changes": "- int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n+ int expPos = Math.max(str.indexOf('e'), str.indexOf('E'));",
            "fixed_method": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear \n        // to be in specification of class. OS X Java parses it to \n        // a wrong value.\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = Math.max(str.indexOf('e'), str.indexOf('E'));\n\n    if (decPos > -1) {\n\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        //Requesting a specific type..\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                        //Too big for a long\n                    }\n                    return createBigInteger(numeric);\n\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f' :\n            case 'F' :\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        //If it's too big for a float or the float value = 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                //$FALL-THROUGH$\n            case 'd' :\n            case 'D' :\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                    // ignore the bad number\n                }\n                //$FALL-THROUGH$\n            default :\n                throw new NumberFormatException(str + \" is not a valid number.\");\n\n        }\n    } else {\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n\n        } else {\n            //Must be a float,double,BigDec\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            try {\n                Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n\n            return createBigDecimal(str);\n\n        }\n    }\n}",
            "diff": "--- original\n+++ fixed\n@@ -0,0 +1,148 @@\n+public static Number createNumber(String str) throws NumberFormatException {\n+    if (str == null) {\n+        return null;\n+    }\n+    if (StringUtils.isBlank(str)) {\n+        throw new NumberFormatException(\"A blank string is not a valid number\");\n+    }  \n+    if (str.startsWith(\"--\")) {\n+        // this is protection for poorness in java.lang.BigDecimal.\n+        // it accepts this as a legal value, but it does not appear \n+        // to be in specification of class. OS X Java parses it to \n+        // a wrong value.\n+        return null;\n+    }\n+    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+        return createInteger(str);\n+    }   \n+    char lastChar = str.charAt(str.length() - 1);\n+    String mant;\n+    String dec;\n+    String exp;\n+    int decPos = str.indexOf('.');\n+    int expPos = Math.max(str.indexOf('e'), str.indexOf('E'));\n+\n+    if (decPos > -1) {\n+\n+        if (expPos > -1) {\n+            if (expPos < decPos) {\n+                throw new NumberFormatException(str + \" is not a valid number.\");\n+            }\n+            dec = str.substring(decPos + 1, expPos);\n+        } else {\n+            dec = str.substring(decPos + 1);\n+        }\n+        mant = str.substring(0, decPos);\n+    } else {\n+        if (expPos > -1) {\n+            mant = str.substring(0, expPos);\n+        } else {\n+            mant = str;\n+        }\n+        dec = null;\n+    }\n+    if (!Character.isDigit(lastChar) && lastChar != '.') {\n+        if (expPos > -1 && expPos < str.length() - 1) {\n+            exp = str.substring(expPos + 1, str.length() - 1);\n+        } else {\n+            exp = null;\n+        }\n+        //Requesting a specific type..\n+        String numeric = str.substring(0, str.length() - 1);\n+        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n+        switch (lastChar) {\n+            case 'l' :\n+            case 'L' :\n+                if (dec == null\n+                    && exp == null\n+                    && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n+                    try {\n+                        return createLong(numeric);\n+                    } catch (NumberFormatException nfe) {\n+                        //Too big for a long\n+                    }\n+                    return createBigInteger(numeric);\n+\n+                }\n+                throw new NumberFormatException(str + \" is not a valid number.\");\n+            case 'f' :\n+            case 'F' :\n+                try {\n+                    Float f = NumberUtils.createFloat(numeric);\n+                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n+                        //If it's too big for a float or the float value = 0 and the string\n+                        //has non-zeros in it, then float does not have the precision we want\n+                        return f;\n+                    }\n+\n+                } catch (NumberFormatException nfe) {\n+                    // ignore the bad number\n+                }\n+                //$FALL-THROUGH$\n+            case 'd' :\n+            case 'D' :\n+                try {\n+                    Double d = NumberUtils.createDouble(numeric);\n+                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n+                        return d;\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                    // ignore the bad number\n+                }\n+                try {\n+                    return createBigDecimal(numeric);\n+                } catch (NumberFormatException e) {\n+                    // ignore the bad number\n+                }\n+                //$FALL-THROUGH$\n+            default :\n+                throw new NumberFormatException(str + \" is not a valid number.\");\n+\n+        }\n+    } else {\n+        //User doesn't have a preference on the return type, so let's start\n+        //small and go from there...\n+        if (expPos > -1 && expPos < str.length() - 1) {\n+            exp = str.substring(expPos + 1, str.length());\n+        } else {\n+            exp = null;\n+        }\n+        if (dec == null && exp == null) {\n+            //Must be an int,long,bigint\n+            try {\n+                return createInteger(str);\n+            } catch (NumberFormatException nfe) {\n+                // ignore the bad number\n+            }\n+            try {\n+                return createLong(str);\n+            } catch (NumberFormatException nfe) {\n+                // ignore the bad number\n+            }\n+            return createBigInteger(str);\n+\n+        } else {\n+            //Must be a float,double,BigDec\n+            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n+            try {\n+                Float f = createFloat(str);\n+                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n+                    return f;\n+                }\n+            } catch (NumberFormatException nfe) {\n+                // ignore the bad number\n+            }\n+            try {\n+                Double d = createDouble(str);\n+                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n+                    return d;\n+                }\n+            } catch (NumberFormatException nfe) {\n+                // ignore the bad number\n+            }\n+\n+            return createBigDecimal(str);\n+\n+        }\n+    }\n+}",
            "file_path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
            "method_name": "createNumber",
            "class_name": "NumberUtils",
            "iteration": 1,
            "is_multi_method": false,
            "line_numbers": [
                452,
                453,
                454,
                455,
                456,
                457,
                458,
                459,
                460,
                461,
                462,
                463,
                464,
                465,
                466,
                467,
                468,
                469,
                470,
                471,
                472,
                473,
                474,
                475,
                476,
                477,
                478,
                479,
                480,
                481,
                482,
                483,
                484,
                485,
                486,
                487,
                488,
                489,
                490,
                491,
                492,
                493,
                494,
                495,
                496,
                497,
                498,
                499,
                500,
                501,
                502,
                503,
                504,
                505,
                506,
                507,
                508,
                509,
                510,
                511,
                512,
                513,
                514,
                515,
                516,
                517,
                518,
                519,
                520,
                521,
                522,
                523,
                524,
                525,
                526,
                527,
                528,
                529,
                530,
                531,
                532,
                533,
                534,
                535,
                536,
                537,
                538,
                539,
                540,
                541,
                542,
                543,
                544,
                545,
                546,
                547,
                548,
                549,
                550,
                551,
                552,
                553,
                554,
                555,
                556,
                557,
                558,
                559,
                560,
                561,
                562,
                563,
                564,
                565,
                566,
                567,
                568,
                569,
                570,
                571,
                572,
                573,
                574,
                575,
                576,
                577,
                578,
                579,
                580,
                581,
                582,
                583,
                584,
                585,
                586,
                587,
                588,
                589,
                590,
                591,
                592,
                593,
                594,
                595,
                596,
                597,
                598,
                599
            ]
        }
    ],
    "iterations": 1,
    "monitor_file": "traces/Lang-27_trace.json"
}