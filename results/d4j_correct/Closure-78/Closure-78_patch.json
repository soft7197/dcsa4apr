{
    "bug_id": "Closure-78",
    "success": true,
    "error": null,
    "patch": null,
    "project_path": "/tmp/d4j_Closure-78_1757168430",
    "patches": [
        {
            "hypothesis": "The method is incorrectly returning a NaN, Infinity or similar representation as a string node instead of handling this in arithmetic expression cases. This causes string comparison failures or other issues as the resulting node can't be folded correctly. Therefore, for non-valid number results and symbols like NaN or Infinity, the transformations should avoid conversion to a string node.",
            "fixed_method": "private Node performArithmeticOp(int opType, Node left, Node right) {\n  // Unlike other operations, ADD operands are not always converted\n  // to Number.\n  if (opType == Token.ADD\n      && (NodeUtil.mayBeString(left, false)\n          || NodeUtil.mayBeString(right, false))) {\n    return null;\n  }\n\n  double result;\n\n  // TODO: Handle NaN with unknown value. BIT ops convert NaN\n  // to zero so this is a little awkward here.\n\n  Double lValObj = NodeUtil.getNumberValue(left);\n  if (lValObj == null) {\n    return null;\n  }\n  Double rValObj = NodeUtil.getNumberValue(right);\n  if (rValObj == null) {\n    return null;\n  }\n\n  double lval = lValObj;\n  double rval = rValObj;\n\n  switch (opType) {\n    case Token.BITAND:\n      result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n      break;\n    case Token.BITOR:\n      result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n      break;\n    case Token.BITXOR:\n      result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n      break;\n    case Token.ADD:\n      result = lval + rval;\n      break;\n    case Token.SUB:\n      result = lval - rval;\n      break;\n    case Token.MUL:\n      result = lval * rval;\n      break;\n    case Token.MOD:\n      if (rval == 0) {\n        return null; // Avoid transformation for divide by zero in MOD.\n      }\n      result = lval % rval;\n      break;\n    case Token.DIV:\n      if (rval == 0) {\n        return null; // Avoid transformation for divide by zero in DIV.\n      }\n      result = lval / rval;\n      break;\n    default:\n      throw new Error(\"Unexpected arithmetic operator\");\n  }\n\n  // Do not try to fold arithmetic for undefined results like NaN.\n  if (Double.isNaN(result) ||\n      result == Double.POSITIVE_INFINITY ||\n      result == Double.NEGATIVE_INFINITY) {\n    return null;\n  }\n\n  // TODO: Consider removing the result length check.\n  // Length of the left and right value plus 1 byte for the operator.\n  if (String.valueOf(result).length() <=\n      String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n\n      // Do not try to fold arithmetic for numbers > 2^53. After that\n      // point, fixed-point math starts to break down and become inaccurate.\n      Math.abs(result) <= MAX_FOLD_NUMBER) {\n    Node newNumber = Node.newNumber(result);\n    return newNumber;\n  }\n\n  return null;\n}",
            "diff": "--- original\n+++ fixed\n@@ -1,6 +1,3 @@\n-/**\n-* Try to fold arithmetic binary operators\n-*/\n private Node performArithmeticOp(int opType, Node left, Node right) {\n   // Unlike other operations, ADD operands are not always converted\n   // to Number.\n@@ -12,8 +9,8 @@\n \n   double result;\n \n-  // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n-  // to zero so this is a little akward here.\n+  // TODO: Handle NaN with unknown value. BIT ops convert NaN\n+  // to zero so this is a little awkward here.\n \n   Double lValObj = NodeUtil.getNumberValue(left);\n   if (lValObj == null) {\n@@ -48,15 +45,13 @@\n       break;\n     case Token.MOD:\n       if (rval == 0) {\n-        error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-        return null;\n+        return null; // Avoid transformation for divide by zero in MOD.\n       }\n       result = lval % rval;\n       break;\n     case Token.DIV:\n       if (rval == 0) {\n-        error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-        return null;\n+        return null; // Avoid transformation for divide by zero in DIV.\n       }\n       result = lval / rval;\n       break;\n@@ -64,8 +59,15 @@\n       throw new Error(\"Unexpected arithmetic operator\");\n   }\n \n-  // TODO(johnlenz): consider removing the result length check.\n-  // length of the left and right value plus 1 byte for the operator.\n+  // Do not try to fold arithmetic for undefined results like NaN.\n+  if (Double.isNaN(result) ||\n+      result == Double.POSITIVE_INFINITY ||\n+      result == Double.NEGATIVE_INFINITY) {\n+    return null;\n+  }\n+\n+  // TODO: Consider removing the result length check.\n+  // Length of the left and right value plus 1 byte for the operator.\n   if (String.valueOf(result).length() <=\n       String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n \n@@ -74,12 +76,6 @@\n       Math.abs(result) <= MAX_FOLD_NUMBER) {\n     Node newNumber = Node.newNumber(result);\n     return newNumber;\n-  } else if (Double.isNaN(result)) {\n-    return Node.newString(Token.NAME, \"NaN\");\n-  } else if (result == Double.POSITIVE_INFINITY) {\n-    return Node.newString(Token.NAME, \"Infinity\");\n-  } else if (result == Double.NEGATIVE_INFINITY) {\n-    return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n   }\n \n   return null;\n",
            "file_path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
            "method_name": "performArithmeticOp",
            "class_name": "PeepholeFoldConstants",
            "iteration": 1,
            "is_multi_method": false,
            "line_numbers": [
                664,
                665,
                666,
                667,
                668,
                669,
                670,
                671,
                672,
                673,
                674,
                675,
                676,
                677,
                678,
                679,
                680,
                681,
                682,
                683,
                684,
                685,
                686,
                687,
                688,
                689,
                690,
                691,
                692,
                693,
                694,
                695,
                696,
                697,
                698,
                699,
                700,
                701,
                702,
                703,
                704,
                705,
                706,
                707,
                708,
                709,
                710,
                711,
                712,
                713,
                714,
                715,
                716,
                717,
                718,
                719,
                720,
                721,
                722,
                723,
                724,
                725,
                726,
                727,
                728,
                729,
                730,
                731,
                732,
                733,
                734,
                735,
                736,
                737,
                738,
                739,
                740,
                741,
                742,
                743,
                744,
                745,
                746
            ]
        }
    ],
    "iterations": 1,
    "monitor_file": "traces/Closure-78_trace.json"
}