### Fixed Method 1
Map<String, String> parsePaxHeaders(final InputStream i) throws IOException {
    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);
    while (true) {
        int ch;
        int len = 0;
        int read = 0;

        // Skip blank lines
        while ((ch = i.read()) == '\n');
        if (ch == -1) { // EOF
            break;
        }

        // Parse length
        do {
            if (ch >= '0' && ch <= '9') {
                len = Math.addExact(Math.multiplyExact(len, 10), ch - '0');
                read++;
            } else if (ch == ' ') {
                break;
            } else {
                throw new IOException("Invalid character in length field");
            }
        } while ((ch = i.read()) != -1);

        if (ch == -1) { // EOF
            throw new IOException("Unexpected EOF after length field");
        }
        read++;

        // Get keyword
        final ByteArrayOutputStream coll = new ByteArrayOutputStream();
        while ((ch = i.read()) != -1) {
            read++;
            if (ch == '=') { // end of keyword
                final String keyword = coll.toString(CharsetNames.UTF_8);
                // Get rest of entry
                final int restLen = len - read;
                if (restLen == 1) { // only NL
                    headers.remove(keyword);
                } else if (restLen > 0) {
                    final byte[] rest = new byte[restLen];
                    final int got = IOUtils.readFully(i, rest);
                    if (got != restLen) {
                        throw new IOException("Failed to read Paxheader. Expected " + restLen + " bytes, read " + got);
                    }
                    // Drop trailing NL
                    final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);
                    headers.put(keyword, value);
                } else {
                    throw new IOException("Invalid rest length: " + restLen);
                }
                break;
            }
            coll.write((byte) ch);
        }

        if (ch == -1) { // EOF
            throw new IOException("Unexpected EOF after keyword");
        }
    }
    return headers;
}
