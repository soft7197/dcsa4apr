{
    "bug_id": "Math-31",
    "success": true,
    "error": null,
    "patch": null,
    "project_path": "/tmp/d4j_Math-31_1757915953",
    "patches": [
        {
            "hypothesis": "The root cause of the error is the incorrect calculation and handling of the continued fraction values, leading to NaN or infinite results. Specifically, the calculation of deltaN and subsequent hN can become NaN when cN or q2 are zero. The fix involves ensuring that cN and q2 are never zero by initializing them with a small value when they are detected as zero, similar to how hPrev is handled initially.",
            "fixed_method": "public double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    // use the value of small as epsilon criteria for zero checks\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 0.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double cN = a * hPrev + b * p0;\n        double q2 = a * q1 + b * dPrev;\n\n        if (Precision.equals(cN, 0.0, small)) {\n            cN = small;\n        }\n        if (Precision.equals(q2, 0.0, small)) {\n            q2 = small;\n        }\n\n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            double scaleFactor = 1d;\n            double lastScaleFactor = 1d;\n            final int maxPower = 5;\n            final double scale = FastMath.max(a, b);\n            if (scale <= 0) {  // Can't scale\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            for (int i = 0; i < maxPower; i++) {\n                lastScaleFactor = scaleFactor;\n                scaleFactor *= scale;\n                if (a != 0.0 && a > b) {\n                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n                } else if (b != 0) {\n                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n                }\n                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                    break;\n                }\n            }\n        }\n\n        final double deltaN = cN / q2 / cPrev;\n        hN = cPrev * deltaN;\n\n        if (Double.isInfinite(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                                           x);\n        }\n        if (Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                                           x);\n        }\n\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        dPrev = q1;\n        cPrev = cN / q2;\n        p0 = hPrev;\n        hPrev = cN;\n        q1 = q2;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                            maxIterations, x);\n    }\n\n    return hN;\n}",
            "diff": "--- original\n+++ fixed\n@@ -1,28 +1,3 @@\n-/**\n-* <p>\n-* Evaluates the continued fraction at the value x.\n-* </p>\n-*\n-* <p>\n-* The implementation of this method is based on the modified Lentz algorithm as described\n-* on page 18 ff. in:\n-* <ul>\n-* <li>\n-*   I. J. Thompson,  A. R. Barnett. \"Coulomb and Bessel Functions of Complex Arguments and Order.\"\n-*   <a target=\"_blank\" href=\"http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf\">\n-*   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>\n-* </li>\n-* </ul>\n-* Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in\n-* <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction / MathWorld</a>.\n-* </p>\n-*\n-* @param x the evaluation point.\n-* @param epsilon maximum error allowed.\n-* @param maxIterations maximum number of convergents\n-* @return the value of the continued fraction evaluated at x.\n-* @throws ConvergenceException if the algorithm fails to converge.\n-*/\n public double evaluate(double x, double epsilon, int maxIterations) {\n     final double small = 1e-50;\n     double hPrev = getA(0, x);\n@@ -45,11 +20,19 @@\n \n         double cN = a * hPrev + b * p0;\n         double q2 = a * q1 + b * dPrev;\n+\n+        if (Precision.equals(cN, 0.0, small)) {\n+            cN = small;\n+        }\n+        if (Precision.equals(q2, 0.0, small)) {\n+            q2 = small;\n+        }\n+\n         if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n             double scaleFactor = 1d;\n             double lastScaleFactor = 1d;\n             final int maxPower = 5;\n-            final double scale = FastMath.max(a,b);\n+            final double scale = FastMath.max(a, b);\n             if (scale <= 0) {  // Can't scale\n                 throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n             }\n",
            "file_path": "src/main/java/org/apache/commons/math3/util/ContinuedFraction.java",
            "method_name": "evaluate",
            "class_name": "ContinuedFraction",
            "iteration": 1,
            "is_multi_method": false,
            "line_numbers": [
                123,
                124,
                125,
                126,
                127,
                128,
                129,
                130,
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                138,
                139,
                140,
                141,
                142,
                143,
                144,
                145,
                146,
                147,
                148,
                149,
                150,
                151,
                152,
                153,
                154,
                155,
                156,
                157,
                158,
                159,
                160,
                161,
                162,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174,
                175,
                176,
                177,
                178,
                179,
                180,
                181,
                182,
                183,
                184,
                185,
                186,
                187,
                188,
                189,
                190,
                191,
                192,
                193,
                194,
                195,
                196,
                197,
                198,
                199
            ],
            "original_code": "/**\n* <p>\n* Evaluates the continued fraction at the value x.\n* </p>\n*\n* <p>\n* The implementation of this method is based on the modified Lentz algorithm as described\n* on page 18 ff. in:\n* <ul>\n* <li>\n*   I. J. Thompson,  A. R. Barnett. \"Coulomb and Bessel Functions of Complex Arguments and Order.\"\n*   <a target=\"_blank\" href=\"http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf\">\n*   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>\n* </li>\n* </ul>\n* Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in\n* <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction / MathWorld</a>.\n* </p>\n*\n* @param x the evaluation point.\n* @param epsilon maximum error allowed.\n* @param maxIterations maximum number of convergents\n* @return the value of the continued fraction evaluated at x.\n* @throws ConvergenceException if the algorithm fails to converge.\n*/\npublic double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    // use the value of small as epsilon criteria for zero checks\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 0.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double cN = a * hPrev + b * p0;\n        double q2 = a * q1 + b * dPrev;\n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            double scaleFactor = 1d;\n            double lastScaleFactor = 1d;\n            final int maxPower = 5;\n            final double scale = FastMath.max(a,b);\n            if (scale <= 0) {  // Can't scale\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            for (int i = 0; i < maxPower; i++) {\n                lastScaleFactor = scaleFactor;\n                scaleFactor *= scale;\n                if (a != 0.0 && a > b) {\n                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n                } else if (b != 0) {\n                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n                }\n                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                    break;\n                }\n            }\n        }\n\n        final double deltaN = cN / q2 / cPrev;\n        hN = cPrev * deltaN;\n\n        if (Double.isInfinite(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                                           x);\n        }\n        if (Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                                           x);\n        }\n\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        dPrev = q1;\n        cPrev = cN / q2;\n        p0 = hPrev;\n        hPrev = cN;\n        q1 = q2;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                            maxIterations, x);\n    }\n\n    return hN;\n}"
        }
    ],
    "iterations": 1,
    "monitor_file": "traces/Math-31_trace.json"
}