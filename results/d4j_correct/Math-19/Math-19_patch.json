{
    "bug_id": "Math-19",
    "success": true,
    "error": null,
    "patch": null,
    "project_path": "/tmp/d4j_Math-19_1757915928",
    "patches": [
        {
            "hypothesis": "The bug arises because the method does not check for cases where the range of the boundaries (uB[i] - lB[i]) is too large, which can cause overflow during normalization. This results in a NaN value when computing the objective value, leading to an unexpected MathIllegalStateException. To fix this, we should explicitly check if the range of any boundary exceeds Double.MAX_VALUE and throw a NumberIsTooLargeException in such cases.",
            "fixed_method": "private void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n\n    // Checks whether there is at least one finite bound value.\n    boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!Double.isInfinite(lB[i]) ||\n            !Double.isInfinite(uB[i])) {\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n    // Checks whether there is at least one infinite bound value.\n    boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) ||\n                Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n\n        if (hasInfiniteBounds) {\n            // If there is at least one finite bound, none can be infinite,\n            // because mixed cases are not supported by the current code.\n            throw new MathUnsupportedOperationException();\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n\n            // Check for overflow in boundary range.\n            for (int i = 0; i < lB.length; i++) {\n                double range = uB[i] - lB[i];\n                if (range > Double.MAX_VALUE) {\n                    throw new NumberIsTooLargeException(range, Double.MAX_VALUE, true);\n                }\n            }\n\n            // Abort early if the normalization will overflow (cf. \"encode\" method).\n        }\n    } else {\n        // Convert API to internal handling of boundaries.\n        boundaries = null;\n    }\n\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {\n            if (inputSigma[i] < 0) {\n                throw new NotPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            }\n        }\n    }\n}",
            "diff": "--- original\n+++ fixed\n@@ -1,6 +1,3 @@\n-/**\n-* Checks dimensions and values of boundaries and inputSigma if defined.\n-*/\n private void checkParameters() {\n     final double[] init = getStartPoint();\n     final double[] lB = getLowerBound();\n@@ -36,6 +33,14 @@\n             boundaries[0] = lB;\n             boundaries[1] = uB;\n \n+            // Check for overflow in boundary range.\n+            for (int i = 0; i < lB.length; i++) {\n+                double range = uB[i] - lB[i];\n+                if (range > Double.MAX_VALUE) {\n+                    throw new NumberIsTooLargeException(range, Double.MAX_VALUE, true);\n+                }\n+            }\n+\n             // Abort early if the normalization will overflow (cf. \"encode\" method).\n         }\n     } else {\n",
            "file_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
            "method_name": "checkParameters",
            "class_name": "CMAESOptimizer",
            "iteration": 1,
            "is_multi_method": false,
            "line_numbers": [
                504,
                505,
                506,
                507,
                508,
                509,
                510,
                511,
                512,
                513,
                514,
                515,
                516,
                517,
                518,
                519,
                520,
                521,
                522,
                523,
                524,
                525,
                526,
                527,
                528,
                529,
                530,
                531,
                532,
                533,
                534,
                535,
                536,
                537,
                538,
                539,
                540,
                541,
                542,
                543,
                544,
                545,
                546,
                547,
                548,
                549,
                550,
                551,
                552,
                553,
                554,
                555,
                556,
                557,
                558,
                559,
                560,
                561
            ],
            "original_code": "/**\n* Checks dimensions and values of boundaries and inputSigma if defined.\n*/\nprivate void checkParameters() {\n    final double[] init = getStartPoint();\n    final double[] lB = getLowerBound();\n    final double[] uB = getUpperBound();\n\n    // Checks whether there is at least one finite bound value.\n    boolean hasFiniteBounds = false;\n    for (int i = 0; i < lB.length; i++) {\n        if (!Double.isInfinite(lB[i]) ||\n            !Double.isInfinite(uB[i])) {\n            hasFiniteBounds = true;\n            break;\n        }\n    }\n    // Checks whether there is at least one infinite bound value.\n    boolean hasInfiniteBounds = false;\n    if (hasFiniteBounds) {\n        for (int i = 0; i < lB.length; i++) {\n            if (Double.isInfinite(lB[i]) ||\n                Double.isInfinite(uB[i])) {\n                hasInfiniteBounds = true;\n                break;\n            }\n        }\n\n        if (hasInfiniteBounds) {\n            // If there is at least one finite bound, none can be infinite,\n            // because mixed cases are not supported by the current code.\n            throw new MathUnsupportedOperationException();\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n\n            // Abort early if the normalization will overflow (cf. \"encode\" method).\n        }\n    } else {\n        // Convert API to internal handling of boundaries.\n        boundaries = null;\n    }\n\n    if (inputSigma != null) {\n        if (inputSigma.length != init.length) {\n            throw new DimensionMismatchException(inputSigma.length, init.length);\n        }\n        for (int i = 0; i < init.length; i++) {\n            if (inputSigma[i] < 0) {\n                throw new NotPositiveException(inputSigma[i]);\n            }\n            if (boundaries != null) {\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                }\n            }\n        }\n    }\n}"
        }
    ],
    "iterations": 1,
    "monitor_file": "traces/Math-19_trace.json"
}