{
    "bug_id": "JacksonCore-25",
    "success": true,
    "error": null,
    "patch": null,
    "project_path": "/tmp/d4j_JacksonCore-25_1757919090",
    "patches": [
        {
            "hypothesis": "The bug is caused by an ArrayIndexOutOfBoundsException when accessing the 'codes' array with an index that exceeds its length. The 'codes' array is not large enough to handle characters with higher ASCII values, such as 256. The fix involves adding a condition to check if 'i' exceeds 'maxCode' and if so, default to not breaking, since 'codes[i]' does not exist.",
            "fixed_method": "// Ok, let's add char to output:\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length - 1;\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        // Ok, let's add char to output:\n        outBuf[outPtr++] = c;\n\n        // Need more room?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}",
            "diff": "--- original\n+++ fixed\n@@ -4,7 +4,7 @@\n     _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n     char[] outBuf = _textBuffer.getCurrentSegment();\n     int outPtr = _textBuffer.getCurrentSegmentSize();\n-    final int maxCode = codes.length;\n+    final int maxCode = codes.length - 1;\n \n     while (true) {\n         if (_inputPtr >= _inputEnd) {\n",
            "file_path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
            "method_name": "_handleOddName2",
            "class_name": "ReaderBasedJsonParser",
            "iteration": 1,
            "is_multi_method": false,
            "line_numbers": [
                1948,
                1949,
                1950,
                1951,
                1952,
                1953,
                1954,
                1955,
                1956,
                1957,
                1958,
                1959,
                1960,
                1961,
                1962,
                1963,
                1964,
                1965,
                1966,
                1967,
                1968,
                1969,
                1970,
                1971,
                1972,
                1973,
                1974,
                1975,
                1976,
                1977,
                1978,
                1979,
                1980,
                1981,
                1982,
                1983,
                1984,
                1985,
                1986,
                1987,
                1988,
                1989,
                1990
            ],
            "original_code": "// Ok, let's add char to output:\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        // Ok, let's add char to output:\n        outBuf[outPtr++] = c;\n\n        // Need more room?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}"
        }
    ],
    "iterations": 1,
    "monitor_file": "traces/JacksonCore-25_trace.json"
}