{
    "bug_id": "JacksonDatabind-62",
    "success": true,
    "error": null,
    "patch": null,
    "project_path": "/tmp/d4j_JacksonDatabind-62_1757762594",
    "patches": [
        {
            "hypothesis": "The error indicates that the method is trying to instantiate an unmodifiable collection, which doesn't have a default constructor. The issue arises because the deserializer isn't correctly handling cases where the collection type is a decorator (like an unmodifiable collection). We need to adjust the deserializer to recognize and handle such cases by delegating the instantiation to the actual modifiable collection that is wrapped.",
            "fixed_method": "/**\n* Method called to finalize setup of this deserializer,\n* when it is known for which property deserializer is needed\n* for.\n*/\npublic CollectionDeserializer createContextual(DeserializationContext ctxt,\n        BeanProperty property) throws JsonMappingException\n{\n    // May need to resolve types for delegate-based creators:\n    JsonDeserializer<Object> delegateDeser = null;\n    if (_valueInstantiator != null) {\n        if (_valueInstantiator.canCreateUsingDelegate()) {\n            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n            if (delegateType == null) {\n                throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType\n                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                        +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n            }\n            delegateDeser = findDeserializer(ctxt, delegateType, property);\n        } else if (_valueInstantiator.canCreateUsingArrayDelegate()) {\n            JavaType arrayDelegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());\n            if (arrayDelegateType == null) {\n                throw new IllegalArgumentException(\"Invalid array-delegate-creator definition for \"+_collectionType\n                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                        +\") returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'\");\n            }\n            delegateDeser = findDeserializer(ctxt, arrayDelegateType, property);\n        }\n    }\n    // [databind#1043]: allow per-property allow-wrapping of single overrides:\n    // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n    //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n    Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n            JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n    // also, often value deserializer is resolved here:\n    JsonDeserializer<?> valueDeser = _valueDeserializer;\n    \n    // May have a content converter\n    valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n    final JavaType vt = _collectionType.getContentType();\n    if (valueDeser == null) {\n        valueDeser = ctxt.findContextualValueDeserializer(vt, property);\n    } else { // if directly assigned, probably not yet contextual, so:\n        valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, vt);\n    }\n    // and finally, type deserializer needs context as well\n    TypeDeserializer valueTypeDeser = _valueTypeDeserializer;\n    if (valueTypeDeser != null) {\n        valueTypeDeser = valueTypeDeser.forProperty(property);\n    }\n    return withResolved(delegateDeser, valueDeser, valueTypeDeser, unwrapSingle);\n}",
            "diff": "--- original\n+++ fixed\n@@ -17,6 +17,14 @@\n                         +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n             }\n             delegateDeser = findDeserializer(ctxt, delegateType, property);\n+        } else if (_valueInstantiator.canCreateUsingArrayDelegate()) {\n+            JavaType arrayDelegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());\n+            if (arrayDelegateType == null) {\n+                throw new IllegalArgumentException(\"Invalid array-delegate-creator definition for \"+_collectionType\n+                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n+                        +\") returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'\");\n+            }\n+            delegateDeser = findDeserializer(ctxt, arrayDelegateType, property);\n         }\n     }\n     // [databind#1043]: allow per-property allow-wrapping of single overrides:\n",
            "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java",
            "method_name": "createContextual",
            "class_name": "CollectionDeserializer",
            "iteration": 1,
            "is_multi_method": false,
            "line_numbers": [
                170,
                171,
                172,
                173,
                174,
                175,
                176,
                177,
                178,
                179,
                180,
                181,
                182,
                183,
                184,
                185,
                186,
                187,
                188,
                189,
                190,
                191,
                192,
                193,
                194,
                195,
                196,
                197,
                198,
                199,
                200,
                201,
                202,
                203,
                204,
                205,
                206,
                207,
                208
            ],
            "original_code": "/**\n* Method called to finalize setup of this deserializer,\n* when it is known for which property deserializer is needed\n* for.\n*/\npublic CollectionDeserializer createContextual(DeserializationContext ctxt,\n        BeanProperty property) throws JsonMappingException\n{\n    // May need to resolve types for delegate-based creators:\n    JsonDeserializer<Object> delegateDeser = null;\n    if (_valueInstantiator != null) {\n        if (_valueInstantiator.canCreateUsingDelegate()) {\n            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n            if (delegateType == null) {\n                throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType\n                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                        +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n            }\n            delegateDeser = findDeserializer(ctxt, delegateType, property);\n        }\n    }\n    // [databind#1043]: allow per-property allow-wrapping of single overrides:\n    // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n    //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n    Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n            JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n    // also, often value deserializer is resolved here:\n    JsonDeserializer<?> valueDeser = _valueDeserializer;\n    \n    // May have a content converter\n    valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n    final JavaType vt = _collectionType.getContentType();\n    if (valueDeser == null) {\n        valueDeser = ctxt.findContextualValueDeserializer(vt, property);\n    } else { // if directly assigned, probably not yet contextual, so:\n        valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, vt);\n    }\n    // and finally, type deserializer needs context as well\n    TypeDeserializer valueTypeDeser = _valueTypeDeserializer;\n    if (valueTypeDeser != null) {\n        valueTypeDeser = valueTypeDeser.forProperty(property);\n    }\n    return withResolved(delegateDeser, valueDeser, valueTypeDeser, unwrapSingle);\n}"
        }
    ],
    "iterations": 1,
    "monitor_file": "traces/JacksonDatabind-62_trace.json"
}