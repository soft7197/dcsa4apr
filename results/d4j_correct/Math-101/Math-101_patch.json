{
    "bug_id": "Math-101",
    "success": true,
    "error": null,
    "patch": null,
    "project_path": "/tmp/d4j_Math-101_1756721424",
    "patches": [
        {
            "hypothesis": "The bug occurs due to an attempt to extract a substring from 'source' beyond its length when the imaginary character is missing. The code assumes the imaginary character is always present, but when it's not, it results in a StringIndexOutOfBoundsException. The fix involves checking if there are enough characters left in the source string before attempting to extract the imaginary character.",
            "changes": "- if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n+ if (endIndex > source.length() || source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {",
            "fixed_method": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n\n    // parse real\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        // invalid real number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n\n    // parse sign\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        // no sign\n        // return real only complex number\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        // invalid sign\n        // set index back to initial, error index should be the last\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n\n    // parse imaginary\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        // invalid imaginary number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n\n    // parse imaginary character\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (endIndex > source.length() || source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n        // set index back to initial, error index should be the start index\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n\n    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n}",
            "diff": "--- original\n+++ fixed\n@@ -0,0 +1,68 @@\n+public Complex parse(String source, ParsePosition pos) {\n+    int initialIndex = pos.getIndex();\n+\n+    // parse whitespace\n+    parseAndIgnoreWhitespace(source, pos);\n+\n+    // parse real\n+    Number re = parseNumber(source, getRealFormat(), pos);\n+    if (re == null) {\n+        // invalid real number\n+        // set index back to initial, error index should already be set\n+        // character examined.\n+        pos.setIndex(initialIndex);\n+        return null;\n+    }\n+\n+    // parse sign\n+    int startIndex = pos.getIndex();\n+    char c = parseNextCharacter(source, pos);\n+    int sign = 0;\n+    switch (c) {\n+    case 0 :\n+        // no sign\n+        // return real only complex number\n+        return new Complex(re.doubleValue(), 0.0);\n+    case '-' :\n+        sign = -1;\n+        break;\n+    case '+' :\n+        sign = 1;\n+        break;\n+    default :\n+        // invalid sign\n+        // set index back to initial, error index should be the last\n+        // character examined.\n+        pos.setIndex(initialIndex);\n+        pos.setErrorIndex(startIndex);\n+        return null;\n+    }\n+\n+    // parse whitespace\n+    parseAndIgnoreWhitespace(source, pos);\n+\n+    // parse imaginary\n+    Number im = parseNumber(source, getRealFormat(), pos);\n+    if (im == null) {\n+        // invalid imaginary number\n+        // set index back to initial, error index should already be set\n+        // character examined.\n+        pos.setIndex(initialIndex);\n+        return null;\n+    }\n+\n+    // parse imaginary character\n+    int n = getImaginaryCharacter().length();\n+    startIndex = pos.getIndex();\n+    int endIndex = startIndex + n;\n+    if (endIndex > source.length() || source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\n+        // set index back to initial, error index should be the start index\n+        // character examined.\n+        pos.setIndex(initialIndex);\n+        pos.setErrorIndex(startIndex);\n+        return null;\n+    }\n+    pos.setIndex(endIndex);\n+\n+    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n+}",
            "file_path": "src/java/org/apache/commons/math/complex/ComplexFormat.java",
            "method_name": "parse",
            "class_name": "ComplexFormat",
            "iteration": 1,
            "is_multi_method": false,
            "line_numbers": [
                320,
                321,
                322,
                323,
                324,
                325,
                326,
                327,
                328,
                329,
                330,
                331,
                332,
                333,
                334,
                335,
                336,
                337,
                338,
                339,
                340,
                341,
                342,
                343,
                344,
                345,
                346,
                347,
                348,
                349,
                350,
                351,
                352,
                353,
                354,
                355,
                356,
                357,
                358,
                359,
                360,
                361,
                362,
                363,
                364,
                365,
                366,
                367,
                368,
                369,
                370,
                371,
                372,
                373,
                374,
                375,
                376,
                377,
                378,
                379,
                380,
                381,
                382,
                383,
                384,
                385,
                386,
                387,
                388,
                389
            ]
        }
    ],
    "iterations": 1,
    "monitor_file": "traces/Math-101_trace.json"
}