{
    "bug_id": "JacksonDatabind-102",
    "success": true,
    "error": null,
    "patch": null,
    "project_path": "/tmp/d4j_JacksonDatabind-102_1757171769",
    "patches": [
        {
            "hypothesis": "The issue arises because the method is returning a numeric timestamp as the result instead of a formatted string. This occurs because the code does not apply the custom pattern override when it detects `property` is not null, leading to the default serialization mechanism being used. The fix is to ensure that the custom pattern override is respected when formatting sql dates.",
            "fixed_method": "public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n        if (format == null) {\n            return this;\n        }\n        // Simple case first: serialize as numeric timestamp?\n        JsonFormat.Shape shape = format.getShape();\n        if (shape.isNumeric()) {\n            return withFormat(Boolean.TRUE, null);\n        }\n\n        // Handle custom pattern if present\n        if (format.hasPattern()) {\n            final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n            SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n            TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n            df.setTimeZone(tz);\n            return withFormat(Boolean.FALSE, df);\n        }\n\n        // Only if pattern is absent, continue with other configurations\n        final boolean hasLocale = format.hasLocale();\n        final boolean hasTZ = format.hasTimeZone();\n        final boolean asString = (shape == JsonFormat.Shape.STRING);\n\n        if (!hasLocale && !hasTZ && !asString) {\n            return this;\n        }\n\n        DateFormat df0 = serializers.getConfig().getDateFormat();\n        // Jackson's own `StdDateFormat` is quite easy to deal with...\n        if (df0 instanceof StdDateFormat) {\n            StdDateFormat std = (StdDateFormat) df0;\n            if (format.hasLocale()) {\n                std = std.withLocale(format.getLocale());\n            }\n            if (format.hasTimeZone()) {\n                std = std.withTimeZone(format.getTimeZone());\n            }\n            return withFormat(Boolean.FALSE, std);\n        }\n\n        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n        //    So: require it be `SimpleDateFormat`; can't config other types\n        if (!(df0 instanceof SimpleDateFormat)) {\n            serializers.reportBadDefinition(handledType(), String.format(\n                    \"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\",\n                    df0.getClass().getName()));\n        }\n        SimpleDateFormat df = (SimpleDateFormat) df0;\n        if (hasLocale) {\n            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n            df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n        } else {\n            df = (SimpleDateFormat) df.clone();\n        }\n        TimeZone newTz = format.getTimeZone();\n        boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n        if (changeTZ) {\n            df.setTimeZone(newTz);\n        }\n        return withFormat(Boolean.FALSE, df);\n    }\n",
            "diff": "--- original\n+++ fixed\n@@ -1,19 +1,4 @@\n-/**\n-* If {@link #_customFormat} is used, we will try to reuse instances in simplest\n-* possible form; thread-safe, but without overhead of <code>ThreadLocal</code>\n-* (not from code, but wrt retaining of possibly large number of format instances\n-* over all threads, properties with custom formats).\n-*\n-* @since 2.9\n-*/\n-    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n-            BeanProperty property) throws JsonMappingException\n-    {\n-        // Note! Should not skip if `property` null since that'd skip check\n-        // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException {\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n@@ -24,20 +9,16 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n-        // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n-        // First: custom pattern will override things\n+        // Handle custom pattern if present\n         if (format.hasPattern()) {\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n+            final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n             SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n-            TimeZone tz = format.hasTimeZone() ? format.getTimeZone()\n-                    : serializers.getTimeZone();\n+            TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n             df.setTimeZone(tz);\n             return withFormat(Boolean.FALSE, df);\n         }\n \n-        // Otherwise, need one of these changes:\n+        // Only if pattern is absent, continue with other configurations\n         final boolean hasLocale = format.hasLocale();\n         final boolean hasTZ = format.hasTimeZone();\n         final boolean asString = (shape == JsonFormat.Shape.STRING);\n@@ -64,8 +45,8 @@\n         //    So: require it be `SimpleDateFormat`; can't config other types\n         if (!(df0 instanceof SimpleDateFormat)) {\n             serializers.reportBadDefinition(handledType(), String.format(\n-\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\",\n-df0.getClass().getName()));\n+                    \"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\",\n+                    df0.getClass().getName()));\n         }\n         SimpleDateFormat df = (SimpleDateFormat) df0;\n         if (hasLocale) {\n@@ -80,4 +61,4 @@\n             df.setTimeZone(newTz);\n         }\n         return withFormat(Boolean.FALSE, df);\n-    }+    }\n",
            "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java",
            "method_name": "createContextual",
            "class_name": "DateTimeSerializerBase",
            "iteration": 1,
            "is_multi_method": false,
            "line_numbers": [
                62,
                63,
                64,
                65,
                66,
                67,
                68,
                69,
                70,
                71,
                72,
                73,
                74,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                82,
                83,
                84,
                85,
                86,
                87,
                88,
                89,
                90,
                91,
                92,
                93,
                94,
                95,
                96,
                97,
                98,
                99,
                100,
                101,
                102,
                103,
                104,
                105,
                106,
                107,
                108,
                109,
                110,
                111,
                112,
                113,
                114,
                115,
                116,
                117,
                118,
                119,
                120,
                121,
                122,
                123,
                124,
                125,
                126,
                127,
                128,
                129,
                130,
                131,
                132,
                133,
                134,
                135,
                136
            ]
        }
    ],
    "iterations": 1,
    "monitor_file": "traces/JacksonDatabind-102_trace.json"
}