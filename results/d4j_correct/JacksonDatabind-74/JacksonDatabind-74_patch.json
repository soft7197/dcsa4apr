{
    "bug_id": "JacksonDatabind-74",
    "success": true,
    "error": null,
    "patch": null,
    "project_path": "/tmp/d4j_JacksonDatabind-74_1757919177",
    "patches": [
        {
            "hypothesis": "The method `_deserializeTypedUsingDefaultImpl` does not handle the case when the JSON contains an empty string properly. The test expects that an empty string is treated as a null object when the `DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT` is enabled. The current implementation does not check for this feature and directly reports a wrong token exception.",
            "fixed_method": "protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt, TokenBuffer tb) throws IOException {\n    // As per [JACKSON-614], may have default implementation to use\n    JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n    if (deser != null) {\n        if (tb != null) {\n            tb.writeEndObject();\n            p = tb.asParser(p);\n            // must move to point to the first token:\n            p.nextToken();\n        }\n        return deser.deserialize(p, ctxt);\n    }\n    // Check if empty string should be treated as null\n    if (p.getCurrentToken() == JsonToken.VALUE_STRING && p.getText().isEmpty() && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n        return null;\n    }\n    // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n    Object result = TypeDeserializer.deserializeIfNatural(p, ctxt, _baseType);\n    if (result != null) {\n        return result;\n    }\n    // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\n    if (p.getCurrentToken() == JsonToken.START_ARRAY) {\n        return super.deserializeTypedFromAny(p, ctxt);\n    }\n    ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME,\n            \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    return null;\n}",
            "diff": "--- original\n+++ fixed\n@@ -1,7 +1,4 @@\n-// off-lined to keep main method lean and mean...\n-protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt,\n-        TokenBuffer tb) throws IOException\n-{\n+protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt, TokenBuffer tb) throws IOException {\n     // As per [JACKSON-614], may have default implementation to use\n     JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n     if (deser != null) {\n@@ -12,6 +9,10 @@\n             p.nextToken();\n         }\n         return deser.deserialize(p, ctxt);\n+    }\n+    // Check if empty string should be treated as null\n+    if (p.getCurrentToken() == JsonToken.VALUE_STRING && p.getText().isEmpty() && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+        return null;\n     }\n     // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n     Object result = TypeDeserializer.deserializeIfNatural(p, ctxt, _baseType);\n",
            "file_path": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java",
            "method_name": "_deserializeTypedUsingDefaultImpl",
            "class_name": "AsPropertyTypeDeserializer",
            "iteration": 1,
            "is_multi_method": false,
            "line_numbers": [
                134,
                135,
                136,
                137,
                138,
                139,
                140,
                141,
                142,
                143,
                144,
                145,
                146,
                147,
                148,
                149,
                150,
                151,
                152,
                153,
                154,
                155,
                156,
                157,
                158,
                159,
                160
            ],
            "original_code": "// off-lined to keep main method lean and mean...\nprotected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt,\n        TokenBuffer tb) throws IOException\n{\n    // As per [JACKSON-614], may have default implementation to use\n    JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n    if (deser != null) {\n        if (tb != null) {\n            tb.writeEndObject();\n            p = tb.asParser(p);\n            // must move to point to the first token:\n            p.nextToken();\n        }\n        return deser.deserialize(p, ctxt);\n    }\n    // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n    Object result = TypeDeserializer.deserializeIfNatural(p, ctxt, _baseType);\n    if (result != null) {\n        return result;\n    }\n    // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\n    if (p.getCurrentToken() == JsonToken.START_ARRAY) {\n        return super.deserializeTypedFromAny(p, ctxt);\n    }\n    ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME,\n            \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    return null;\n}"
        }
    ],
    "iterations": 1,
    "monitor_file": "traces/JacksonDatabind-74_trace.json"
}