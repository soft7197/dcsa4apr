{
    "bug_id": "Closure-73",
    "success": true,
    "error": null,
    "patch": null,
    "project_path": "/tmp/d4j_Closure-73_1756720664",
    "patches": [
        {
            "hypothesis": "The bug is caused by characters in the range above 0x7f not being escaped into their Unicode representation when no CharsetEncoder is provided, as the code currently only checks for characters up to 0x7f. Characters above this range should be escaped using Unicode escape sequences.",
            "changes": [
                "- if (c > 0x1f && c <= 0x7f) {",
                "+ if (c > 0x1f && c < 0x7f) {"
            ],
            "fixed_method": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n        if (i >= 2 &&\n            ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n             (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n          sb.append(\"\\\\>\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      case '<':\n        // Break </script into <\\/script\n        final String END_SCRIPT = \"/script\";\n\n        // Break <!-- into <\\!--\n        final String START_COMMENT = \"!--\";\n\n        if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                            END_SCRIPT.length())) {\n          sb.append(\"<\\\\\");\n        } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                   START_COMMENT.length())) {\n          sb.append(\"<\\\\\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      default:\n        // If we're given an outputCharsetEncoder, then check if the\n        //  character can be represented in this character set.\n        if (outputCharsetEncoder != null) {\n          if (outputCharsetEncoder.canEncode(c)) {\n            sb.append(c);\n          } else {\n            // Unicode-escape the character.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        } else {\n          // No charsetEncoder provided - pass straight latin characters\n          // through, and escape the rest.  Doing the explicit character\n          // check is measurably faster than using the CharsetEncoder.\n          if (c > 0x1f && c < 0x7f) {\n            sb.append(c);\n          } else {\n            // Other characters can be misinterpreted by some js parsers,\n            // or perhaps mangled by proxies along the way,\n            // so we play it safe and unicode escape them.\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
            "diff": "--- original\n+++ fixed\n@@ -0,0 +1,71 @@\n+static String strEscape(String s, char quote,\n+                        String doublequoteEscape,\n+                        String singlequoteEscape,\n+                        String backslashEscape,\n+                        CharsetEncoder outputCharsetEncoder) {\n+  StringBuilder sb = new StringBuilder(s.length() + 2);\n+  sb.append(quote);\n+  for (int i = 0; i < s.length(); i++) {\n+    char c = s.charAt(i);\n+    switch (c) {\n+      case '\\0': sb.append(\"\\\\0\"); break;\n+      case '\\n': sb.append(\"\\\\n\"); break;\n+      case '\\r': sb.append(\"\\\\r\"); break;\n+      case '\\t': sb.append(\"\\\\t\"); break;\n+      case '\\\\': sb.append(backslashEscape); break;\n+      case '\"': sb.append(doublequoteEscape); break;\n+      case '\\'': sb.append(singlequoteEscape); break;\n+      case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n+        if (i >= 2 &&\n+            ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n+             (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n+          sb.append(\"\\\\>\");\n+        } else {\n+          sb.append(c);\n+        }\n+        break;\n+      case '<':\n+        // Break </script into <\\/script\n+        final String END_SCRIPT = \"/script\";\n+\n+        // Break <!-- into <\\!--\n+        final String START_COMMENT = \"!--\";\n+\n+        if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n+                            END_SCRIPT.length())) {\n+          sb.append(\"<\\\\\");\n+        } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n+                                   START_COMMENT.length())) {\n+          sb.append(\"<\\\\\");\n+        } else {\n+          sb.append(c);\n+        }\n+        break;\n+      default:\n+        // If we're given an outputCharsetEncoder, then check if the\n+        //  character can be represented in this character set.\n+        if (outputCharsetEncoder != null) {\n+          if (outputCharsetEncoder.canEncode(c)) {\n+            sb.append(c);\n+          } else {\n+            // Unicode-escape the character.\n+            appendHexJavaScriptRepresentation(sb, c);\n+          }\n+        } else {\n+          // No charsetEncoder provided - pass straight latin characters\n+          // through, and escape the rest.  Doing the explicit character\n+          // check is measurably faster than using the CharsetEncoder.\n+          if (c > 0x1f && c < 0x7f) {\n+            sb.append(c);\n+          } else {\n+            // Other characters can be misinterpreted by some js parsers,\n+            // or perhaps mangled by proxies along the way,\n+            // so we play it safe and unicode escape them.\n+            appendHexJavaScriptRepresentation(sb, c);\n+          }\n+        }\n+    }\n+  }\n+  sb.append(quote);\n+  return sb.toString();\n+}",
            "file_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
            "method_name": "strEscape",
            "class_name": "CodeGenerator",
            "iteration": 1,
            "is_multi_method": false,
            "line_numbers": [
                988,
                989,
                990,
                991,
                992,
                993,
                994,
                995,
                996,
                997,
                998,
                999,
                1000,
                1001,
                1002,
                1003,
                1004,
                1005,
                1006,
                1007,
                1008,
                1009,
                1010,
                1011,
                1012,
                1013,
                1014,
                1015,
                1016,
                1017,
                1018,
                1019,
                1020,
                1021,
                1022,
                1023,
                1024,
                1025,
                1026,
                1027,
                1028,
                1029,
                1030,
                1031,
                1032,
                1033,
                1034,
                1035,
                1036,
                1037,
                1038,
                1039,
                1040,
                1041,
                1042,
                1043,
                1044,
                1045,
                1046,
                1047,
                1048,
                1049,
                1050,
                1051,
                1052,
                1053,
                1054,
                1055,
                1056,
                1057,
                1058
            ]
        }
    ],
    "iterations": 1,
    "monitor_file": "traces/Closure-73_trace.json"
}