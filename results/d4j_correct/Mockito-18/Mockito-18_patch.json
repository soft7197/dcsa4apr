{
    "bug_id": "Mockito-18",
    "success": true,
    "error": null,
    "patch": null,
    "project_path": "/tmp/d4j_Mockito-18_1756883972",
    "patches": [
        {
            "hypothesis": "The method does not handle the Iterable interface, which causes a NullPointerException when the test expects an empty Iterable. Adding a case for Iterable to return an empty collection will fix the issue.",
            "changes": "+ } else if (type == Iterable.class) {\n+     return new LinkedList<Object>();",
            "fixed_method": "Object returnValueFor(Class<?> type) {\n    if (Primitives.isPrimitiveOrWrapper(type)) {\n        return Primitives.defaultValueForPrimitiveOrWrapper(type);\n        //new instances are used instead of Collections.emptyList(), etc.\n        //to avoid UnsupportedOperationException if code under test modifies returned collection\n    } else if (type == Collection.class) {\n        return new LinkedList<Object>();\n    } else if (type == Set.class) {\n        return new HashSet<Object>();\n    } else if (type == HashSet.class) {\n        return new HashSet<Object>();\n    } else if (type == SortedSet.class) {\n        return new TreeSet<Object>();\n    } else if (type == TreeSet.class) {\n        return new TreeSet<Object>();\n    } else if (type == LinkedHashSet.class) {\n        return new LinkedHashSet<Object>();\n    } else if (type == List.class) {\n        return new LinkedList<Object>();\n    } else if (type == LinkedList.class) {\n        return new LinkedList<Object>();\n    } else if (type == ArrayList.class) {\n        return new ArrayList<Object>();\n    } else if (type == Map.class) {\n        return new HashMap<Object, Object>();\n    } else if (type == HashMap.class) {\n        return new HashMap<Object, Object>();\n    } else if (type == SortedMap.class) {\n        return new TreeMap<Object, Object>();\n    } else if (type == TreeMap.class) {\n        return new TreeMap<Object, Object>();\n    } else if (type == LinkedHashMap.class) {\n        return new LinkedHashMap<Object, Object>();\n    } else if (type == Iterable.class) {\n        return new LinkedList<Object>();\n    }\n    //Let's not care about the rest of collections.\n    return null;\n}",
            "diff": "--- original\n+++ fixed\n@@ -0,0 +1,39 @@\n+Object returnValueFor(Class<?> type) {\n+    if (Primitives.isPrimitiveOrWrapper(type)) {\n+        return Primitives.defaultValueForPrimitiveOrWrapper(type);\n+        //new instances are used instead of Collections.emptyList(), etc.\n+        //to avoid UnsupportedOperationException if code under test modifies returned collection\n+    } else if (type == Collection.class) {\n+        return new LinkedList<Object>();\n+    } else if (type == Set.class) {\n+        return new HashSet<Object>();\n+    } else if (type == HashSet.class) {\n+        return new HashSet<Object>();\n+    } else if (type == SortedSet.class) {\n+        return new TreeSet<Object>();\n+    } else if (type == TreeSet.class) {\n+        return new TreeSet<Object>();\n+    } else if (type == LinkedHashSet.class) {\n+        return new LinkedHashSet<Object>();\n+    } else if (type == List.class) {\n+        return new LinkedList<Object>();\n+    } else if (type == LinkedList.class) {\n+        return new LinkedList<Object>();\n+    } else if (type == ArrayList.class) {\n+        return new ArrayList<Object>();\n+    } else if (type == Map.class) {\n+        return new HashMap<Object, Object>();\n+    } else if (type == HashMap.class) {\n+        return new HashMap<Object, Object>();\n+    } else if (type == SortedMap.class) {\n+        return new TreeMap<Object, Object>();\n+    } else if (type == TreeMap.class) {\n+        return new TreeMap<Object, Object>();\n+    } else if (type == LinkedHashMap.class) {\n+        return new LinkedHashMap<Object, Object>();\n+    } else if (type == Iterable.class) {\n+        return new LinkedList<Object>();\n+    }\n+    //Let's not care about the rest of collections.\n+    return null;\n+}",
            "file_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java",
            "method_name": "returnValueFor",
            "class_name": "ReturnsEmptyValues",
            "iteration": 1,
            "is_multi_method": false,
            "line_numbers": [
                82,
                83,
                84,
                85,
                86,
                87,
                88,
                89,
                90,
                91,
                92,
                93,
                94,
                95,
                96,
                97,
                98,
                99,
                100,
                101,
                102,
                103,
                104,
                105,
                106,
                107,
                108,
                109,
                110,
                111,
                112,
                113,
                114,
                115,
                116,
                117,
                118
            ]
        }
    ],
    "iterations": 1,
    "monitor_file": "traces/Mockito-18_trace.json"
}