{
    "bug_id": "Mockito-13",
    "success": true,
    "error": null,
    "patch": null,
    "project_path": "/tmp/d4j_Mockito-13_1756721748",
    "patches": [
        {
            "hypothesis": "The issue lies in how the verification mode is being used or reapplied when the invocation is on a different mock. The current logic does not correctly re-add the verification mode when a mismatch is found, which might cause verification state issues.",
            "changes": "Adjusted the logic to reapply the verification mode when the verification is attempted on a different mock.",
            "fixed_method": "public Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    //if verificationMode is not null then someone is doing verify()        \n    if (verificationMode != null) {\n        //We need to check if verification was started on the correct mock \n        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n            verificationMode.verify(data);\n            return null;\n        } else { // re-add verification mode if the mock doesn't match\n            mockingProgress.verificationStarted(verificationMode);\n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n        // redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside 'when' might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}",
            "diff": "--- original\n+++ fixed\n@@ -0,0 +1,49 @@\n+public Object handle(Invocation invocation) throws Throwable {\n+    if (invocationContainerImpl.hasAnswersForStubbing()) {\n+        // stubbing voids with stubVoid() or doAnswer() style\n+        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n+                        .getArgumentMatcherStorage(), invocation);\n+        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n+        return null;\n+    }\n+    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n+\n+    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n+                    invocation);\n+\n+    mockingProgress.validateState();\n+\n+    //if verificationMode is not null then someone is doing verify()        \n+    if (verificationMode != null) {\n+        //We need to check if verification was started on the correct mock \n+        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n+        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n+            verificationMode.verify(data);\n+            return null;\n+        } else { // re-add verification mode if the mock doesn't match\n+            mockingProgress.verificationStarted(verificationMode);\n+        }\n+    }\n+    \n+    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n+    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n+    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n+\n+    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n+\n+    if (stubbedInvocation != null) {\n+        stubbedInvocation.captureArgumentsFrom(invocation);\n+        return stubbedInvocation.answer(invocation);\n+    } else {\n+        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n+\n+        // redo setting invocation for potential stubbing in case of partial\n+        // mocks / spies.\n+        // Without it, the real method inside 'when' might have delegated\n+        // to other self method and overwrite the intended stubbed method\n+        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n+        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n+        return ret;\n+    }\n+}",
            "file_path": "src/org/mockito/internal/MockHandler.java",
            "method_name": "handle",
            "class_name": "MockHandler",
            "iteration": 1,
            "is_multi_method": false,
            "line_numbers": [
                58,
                59,
                60,
                61,
                62,
                63,
                64,
                65,
                66,
                67,
                68,
                69,
                70,
                71,
                72,
                73,
                74,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                82,
                83,
                84,
                85,
                86,
                87,
                88,
                89,
                90,
                91,
                92,
                93,
                94,
                95,
                96,
                97,
                98,
                99,
                100,
                101,
                102,
                103,
                104,
                105,
                106
            ]
        }
    ],
    "iterations": 1,
    "monitor_file": "traces/Mockito-13_trace.json"
}