{
    "bug_id": "Chart-7",
    "success": true,
    "error": null,
    "patch": null,
    "project_path": "/tmp/d4j_Chart-7_1756719413",
    "patches": [
        {
            "hypothesis": "The issue lies in the calculation and assignment of maxMiddleIndex. The incorrect index is being used to fetch the existing max middle value during comparisons, causing incorrect updates. Specifically, the maxMiddleIndex condition is using the minMiddleIndex variable erroneously.",
            "changes": "- long s = getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime();\n- long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd().getTime();\n+ long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart().getTime();\n+ long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd().getTime();",
            "fixed_method": "private void updateBounds(TimePeriod period, int index) {\n    \n    long start = period.getStart().getTime();\n    long end = period.getEnd().getTime();\n    long middle = start + ((end - start) / 2);\n\n    if (this.minStartIndex >= 0) {\n        long minStart = getDataItem(this.minStartIndex).getPeriod()\n            .getStart().getTime();\n        if (start < minStart) {\n            this.minStartIndex = index;           \n        }\n    }\n    else {\n        this.minStartIndex = index;\n    }\n    \n    if (this.maxStartIndex >= 0) {\n        long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n            .getStart().getTime();\n        if (start > maxStart) {\n            this.maxStartIndex = index;           \n        }\n    }\n    else {\n        this.maxStartIndex = index;\n    }\n    \n    if (this.minMiddleIndex >= 0) {\n        long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n            .getTime();\n        long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n            .getTime();\n        long minMiddle = s + (e - s) / 2;\n        if (middle < minMiddle) {\n            this.minMiddleIndex = index;           \n        }\n    }\n    else {\n        this.minMiddleIndex = index;\n    }\n    \n    if (this.maxMiddleIndex >= 0) {\n        long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\n            .getTime();\n        long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\n            .getTime();\n        long maxMiddle = s + (e - s) / 2;\n        if (middle > maxMiddle) {\n            this.maxMiddleIndex = index;           \n        }\n    }\n    else {\n        this.maxMiddleIndex = index;\n    }\n    \n    if (this.minEndIndex >= 0) {\n        long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n            .getTime();\n        if (end < minEnd) {\n            this.minEndIndex = index;           \n        }\n    }\n    else {\n        this.minEndIndex = index;\n    }\n   \n    if (this.maxEndIndex >= 0) {\n        long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n            .getTime();\n        if (end > maxEnd) {\n            this.maxEndIndex = index;           \n        }\n    }\n    else {\n        this.maxEndIndex = index;\n    }\n    \n}",
            "diff": "--- original\n+++ fixed\n@@ -0,0 +1,79 @@\n+private void updateBounds(TimePeriod period, int index) {\n+    \n+    long start = period.getStart().getTime();\n+    long end = period.getEnd().getTime();\n+    long middle = start + ((end - start) / 2);\n+\n+    if (this.minStartIndex >= 0) {\n+        long minStart = getDataItem(this.minStartIndex).getPeriod()\n+            .getStart().getTime();\n+        if (start < minStart) {\n+            this.minStartIndex = index;           \n+        }\n+    }\n+    else {\n+        this.minStartIndex = index;\n+    }\n+    \n+    if (this.maxStartIndex >= 0) {\n+        long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n+            .getStart().getTime();\n+        if (start > maxStart) {\n+            this.maxStartIndex = index;           \n+        }\n+    }\n+    else {\n+        this.maxStartIndex = index;\n+    }\n+    \n+    if (this.minMiddleIndex >= 0) {\n+        long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n+            .getTime();\n+        long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+            .getTime();\n+        long minMiddle = s + (e - s) / 2;\n+        if (middle < minMiddle) {\n+            this.minMiddleIndex = index;           \n+        }\n+    }\n+    else {\n+        this.minMiddleIndex = index;\n+    }\n+    \n+    if (this.maxMiddleIndex >= 0) {\n+        long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\n+            .getTime();\n+        long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\n+            .getTime();\n+        long maxMiddle = s + (e - s) / 2;\n+        if (middle > maxMiddle) {\n+            this.maxMiddleIndex = index;           \n+        }\n+    }\n+    else {\n+        this.maxMiddleIndex = index;\n+    }\n+    \n+    if (this.minEndIndex >= 0) {\n+        long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n+            .getTime();\n+        if (end < minEnd) {\n+            this.minEndIndex = index;           \n+        }\n+    }\n+    else {\n+        this.minEndIndex = index;\n+    }\n+   \n+    if (this.maxEndIndex >= 0) {\n+        long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n+            .getTime();\n+        if (end > maxEnd) {\n+            this.maxEndIndex = index;           \n+        }\n+    }\n+    else {\n+        this.maxEndIndex = index;\n+    }\n+    \n+}",
            "file_path": "source/org/jfree/data/time/TimePeriodValues.java",
            "method_name": "updateBounds",
            "class_name": "TimePeriodValues",
            "iteration": 1,
            "is_multi_method": false,
            "line_numbers": [
                257,
                258,
                259,
                260,
                261,
                262,
                263,
                264,
                265,
                266,
                267,
                268,
                269,
                270,
                271,
                272,
                273,
                274,
                275,
                276,
                277,
                278,
                279,
                280,
                281,
                282,
                283,
                284,
                285,
                286,
                287,
                288,
                289,
                290,
                291,
                292,
                293,
                294,
                295,
                296,
                297,
                298,
                299,
                300,
                301,
                302,
                303,
                304,
                305,
                306,
                307,
                308,
                309,
                310,
                311,
                312,
                313,
                314,
                315,
                316,
                317,
                318,
                319,
                320,
                321,
                322,
                323,
                324,
                325,
                326,
                327,
                328,
                329,
                330,
                331,
                332,
                333,
                334,
                335
            ]
        }
    ],
    "iterations": 1,
    "monitor_file": "traces/Chart-7_trace.json"
}