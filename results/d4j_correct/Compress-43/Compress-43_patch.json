{
    "bug_id": "Compress-43",
    "success": true,
    "error": null,
    "patch": null,
    "project_path": "/tmp/d4j_Compress-43_1757271578",
    "patches": [
        {
            "hypothesis": "The test failure indicates that a data descriptor is being incorrectly used when adding raw entries, as reflected by the incorrect GeneralPurposeBit flag set in the local file header. This issue arises due to the method 'usesDataDescriptor' returning true in situations where it should not, specifically when working with raw entries. The fix should ensure that the flag for using data descriptors is accurately determined based on the entry type and its compression method, especially differentiating between raw and non-raw entries.",
            "methods": [
                {
                    "method_name": "writeLocalFileHeader",
                    "fixed_method": "private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze, phased)));\n    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}",
                    "diff": "--- original\n+++ fixed\n@@ -1,16 +1,15 @@\n+private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n+    final boolean encodable = zipEncoding.canEncode(ze.getName());\n+    final ByteBuffer name = getName(ze);\n \n-    private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n-        final boolean encodable = zipEncoding.canEncode(ze.getName());\n-        final ByteBuffer name = getName(ze);\n+    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n+        addUnicodeExtraFields(ze, encodable, name);\n+    }\n \n-        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n-            addUnicodeExtraFields(ze, encodable, name);\n-        }\n-\n-        final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n-        final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n-        metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n-        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n-        writeCounted(localHeader);\n-        entry.dataStart = streamCompressor.getTotalBytesWritten();\n-    }\n+    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n+    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n+    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze, phased)));\n+    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n+    writeCounted(localHeader);\n+    entry.dataStart = streamCompressor.getTotalBytesWritten();\n+}",
                    "line_numbers": [
                        1024,
                        1039
                    ],
                    "file_path": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java"
                },
                {
                    "method_name": "createLocalFileHeader",
                    "fixed_method": "private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\n                                     final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx =\n        (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET +\n                        name.limit() - name.position() +\n                        ze.getLocalFileDataExtra().length;\n\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE\n                        - ResourceAlignmentExtraField.BASE_SIZE) &\n                        (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment,\n                        oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n\n    System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(ze, phased);\n\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n    // CRC\n    if (phased){\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(entry.entry)){\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else { // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n    // file name\n    System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n\n    return buf;\n}",
                    "diff": "--- original\n+++ fixed\n@@ -1,88 +1,87 @@\n+private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\n+                                     final boolean phased, long archiveOffset) throws IOException {\n+    ResourceAlignmentExtraField oldAlignmentEx =\n+        (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n+    if (oldAlignmentEx != null) {\n+        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n+    }\n \n-    private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\n-                                         final boolean phased, long archiveOffset) throws IOException {\n-        ResourceAlignmentExtraField oldAlignmentEx =\n-            (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n-        if (oldAlignmentEx != null) {\n-            ze.removeExtraField(ResourceAlignmentExtraField.ID);\n-        }\n+    int alignment = ze.getAlignment();\n+    if (alignment <= 0 && oldAlignmentEx != null) {\n+        alignment = oldAlignmentEx.getAlignment();\n+    }\n \n-        int alignment = ze.getAlignment();\n-        if (alignment <= 0 && oldAlignmentEx != null) {\n-            alignment = oldAlignmentEx.getAlignment();\n-        }\n+    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n+        int oldLength = LFH_FILENAME_OFFSET +\n+                        name.limit() - name.position() +\n+                        ze.getLocalFileDataExtra().length;\n \n-        if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n-            int oldLength = LFH_FILENAME_OFFSET +\n-                            name.limit() - name.position() +\n-                            ze.getLocalFileDataExtra().length;\n+        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE\n+                        - ResourceAlignmentExtraField.BASE_SIZE) &\n+                        (alignment - 1));\n+        ze.addExtraField(new ResourceAlignmentExtraField(alignment,\n+                        oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n+    }\n \n-            int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE\n-                            - ResourceAlignmentExtraField.BASE_SIZE) &\n-                            (alignment - 1));\n-            ze.addExtraField(new ResourceAlignmentExtraField(alignment,\n-                            oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n-        }\n+    final byte[] extra = ze.getLocalFileDataExtra();\n+    final int nameLen = name.limit() - name.position();\n+    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n+    final byte[] buf = new byte[len];\n \n-        final byte[] extra = ze.getLocalFileDataExtra();\n-        final int nameLen = name.limit() - name.position();\n-        final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n-        final byte[] buf = new byte[len];\n+    System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n \n-        System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n+    //store method in local variable to prevent multiple method calls\n+    final int zipMethod = ze.getMethod();\n+    final boolean dataDescriptor = usesDataDescriptor(ze, phased);\n \n-        //store method in local variable to prevent multiple method calls\n-        final int zipMethod = ze.getMethod();\n-        final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n+    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n \n-        putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n+    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n+    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n \n-        final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n-        generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n+    // compression method\n+    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n \n-        // compression method\n-        putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n+    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n \n-        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n+    // CRC\n+    if (phased){\n+        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n+    } else if (zipMethod == DEFLATED || channel != null) {\n+        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n+    } else {\n+        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n+    }\n \n-        // CRC\n-        if (phased){\n-            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n-        } else if (zipMethod == DEFLATED || channel != null) {\n-            System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n-        } else {\n-            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n-        }\n+    // compressed length\n+    // uncompressed length\n+    if (hasZip64Extra(entry.entry)){\n+        // point to ZIP64 extended information extra field for\n+        // sizes, may get rewritten once sizes are known if\n+        // stream is seekable\n+        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n+        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n+    } else if (phased) {\n+        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n+        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n+    } else if (zipMethod == DEFLATED || channel != null) {\n+        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n+        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n+    } else { // Stored\n+        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n+        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n+    }\n+    // file name length\n+    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n \n-        // compressed length\n-        // uncompressed length\n-        if (hasZip64Extra(entry.entry)){\n-            // point to ZIP64 extended information extra field for\n-            // sizes, may get rewritten once sizes are known if\n-            // stream is seekable\n-            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n-            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n-        } else if (phased) {\n-            putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n-            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n-        } else if (zipMethod == DEFLATED || channel != null) {\n-            System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n-            System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n-        } else { // Stored\n-            putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n-            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n-        }\n-        // file name length\n-        putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n+    // extra field length\n+    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n \n-        // extra field length\n-        putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n+    // file name\n+    System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n \n-        // file name\n-        System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n+    // extra fields\n+    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n \n-        // extra fields\n-        System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n-\n-        return buf;\n-    }\n+    return buf;\n+}",
                    "line_numbers": [
                        1041,
                        1128
                    ],
                    "file_path": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java"
                },
                {
                    "method_name": "writeDataDescriptor",
                    "fixed_method": "protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (ze.getMethod() != DEFLATED || channel != null || !usesDataDescriptor(ze, false)) {\n        return;\n    }\n    writeCounted(DD_SIG);\n    writeCounted(ZipLong.getBytes(ze.getCrc()));\n    if (!hasZip64Extra(ze)) {\n        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipLong.getBytes(ze.getSize()));\n    } else {\n        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n    }\n}",
                    "diff": "--- original\n+++ fixed\n@@ -1,20 +1,14 @@\n-    /**\n-     * Writes the data descriptor entry.\n-     * @param ze the entry to write\n-     * @throws IOException on error\n-     */\n-\n-    protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n-        if (ze.getMethod() != DEFLATED || channel != null) {\n-            return;\n-        }\n-        writeCounted(DD_SIG);\n-        writeCounted(ZipLong.getBytes(ze.getCrc()));\n-        if (!hasZip64Extra(ze)) {\n-            writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n-            writeCounted(ZipLong.getBytes(ze.getSize()));\n-        } else {\n-            writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n-            writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n-        }\n+protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n+    if (ze.getMethod() != DEFLATED || channel != null || !usesDataDescriptor(ze, false)) {\n+        return;\n     }\n+    writeCounted(DD_SIG);\n+    writeCounted(ZipLong.getBytes(ze.getCrc()));\n+    if (!hasZip64Extra(ze)) {\n+        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n+        writeCounted(ZipLong.getBytes(ze.getSize()));\n+    } else {\n+        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n+        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n+    }\n+}",
                    "line_numbers": [
                        1170,
                        1184
                    ],
                    "file_path": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java"
                },
                {
                    "method_name": "usesDataDescriptor",
                    "fixed_method": "private boolean usesDataDescriptor(final ZipArchiveEntry ze, final boolean phased) {\n    return ze.getMethod() == DEFLATED && channel == null && !phased;\n}",
                    "diff": "--- original\n+++ fixed\n@@ -1,4 +1,3 @@\n-\n-    private boolean usesDataDescriptor(final int zipMethod) {\n-        return zipMethod == DEFLATED && channel == null;\n-    }\n+private boolean usesDataDescriptor(final ZipArchiveEntry ze, final boolean phased) {\n+    return ze.getMethod() == DEFLATED && channel == null && !phased;\n+}",
                    "line_numbers": [
                        1492,
                        1495
                    ],
                    "file_path": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java"
                }
            ],
            "is_multi_method": true,
            "coordination_notes": "",
            "methods_count": 4
        }
    ],
    "iterations": 2,
    "monitor_file": "traces/Compress-43_trace.json"
}