{
    "bug_id": "JacksonXml-3",
    "success": true,
    "error": null,
    "patch": null,
    "project_path": "/tmp/d4j_JacksonXml-3_1756721146",
    "patches": [
        {
            "hypothesis": "The method `nextTextValue` is not handling XML attributes correctly when it should return their values as strings. Specifically, when encountering an XML attribute value, the method should directly return the value instead of setting _currText and returning null.",
            "changes": "- return _currText; (in case XmlTokenStream.XML_ATTRIBUTE_VALUE)",
            "fixed_method": "public String nextTextValue() throws IOException\n{\n    _binaryValue = null;\n    if (_nextToken != null) {\n        JsonToken t = _nextToken;\n        _currToken = t;\n        _nextToken = null;\n\n        // expected case; yes, got a String\n        if (t == JsonToken.VALUE_STRING) {\n            return _currText;\n        }\n        _updateState(t);\n        return null;\n    }\n\n    int token = _xmlTokens.next();\n\n    // mostly copied from 'nextToken()'\n    while (token == XmlTokenStream.XML_START_ELEMENT) {\n        if (_mayBeLeaf) {\n            _nextToken = JsonToken.FIELD_NAME;\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            _currToken = JsonToken.START_OBJECT;\n            return null;\n        }\n        if (_parsingContext.inArray()) {\n            token = _xmlTokens.next();\n            _mayBeLeaf = true;\n            continue;\n        }\n        String name = _xmlTokens.getLocalName();\n        _parsingContext.setCurrentName(name);\n        if (_namesToWrap != null && _namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _mayBeLeaf = true;\n        _currToken = JsonToken.FIELD_NAME;\n        return null;\n    }\n\n    // Ok; beyond start element, what do we get?\n    switch (token) {\n    case XmlTokenStream.XML_END_ELEMENT:\n        if (_mayBeLeaf) {\n            // NOTE: this is different from nextToken() -- produce \"\", NOT null\n            _mayBeLeaf = false;\n            _currToken = JsonToken.VALUE_STRING;\n            return (_currText = \"\");\n        }\n        _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n        _parsingContext = _parsingContext.getParent();\n        _namesToWrap = _parsingContext.getNamesToWrap();\n        break;\n    case XmlTokenStream.XML_ATTRIBUTE_NAME:\n        // If there was a chance of leaf node, no more...\n        if (_mayBeLeaf) {\n            _mayBeLeaf = false;\n            _nextToken = JsonToken.FIELD_NAME;\n            _currText = _xmlTokens.getText();\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            _currToken = JsonToken.START_OBJECT;\n        } else {\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            _currToken = JsonToken.FIELD_NAME;\n        }\n        break;\n    case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n        _currText = _xmlTokens.getText();\n        _currToken = JsonToken.VALUE_STRING;\n        return _currText;\n    case XmlTokenStream.XML_TEXT:\n        _currText = _xmlTokens.getText();\n        if (_mayBeLeaf) {\n            _mayBeLeaf = false;\n            // Also: must skip following END_ELEMENT\n            _xmlTokens.skipEndElement();\n\n            // NOTE: this is different from nextToken() -- NO work-around\n            // for otherwise empty List/array\n            _currToken = JsonToken.VALUE_STRING;\n            return _currText;\n        }\n        // If not a leaf, need to transform into property...\n        _parsingContext.setCurrentName(_cfgNameForTextElement);\n        _nextToken = JsonToken.VALUE_STRING;\n        _currToken = JsonToken.FIELD_NAME;\n        break;\n    case XmlTokenStream.XML_END:\n        _currToken = null;\n    }\n    return null;\n}",
            "diff": "--- original\n+++ fixed\n@@ -0,0 +1,93 @@\n+public String nextTextValue() throws IOException\n+{\n+    _binaryValue = null;\n+    if (_nextToken != null) {\n+        JsonToken t = _nextToken;\n+        _currToken = t;\n+        _nextToken = null;\n+\n+        // expected case; yes, got a String\n+        if (t == JsonToken.VALUE_STRING) {\n+            return _currText;\n+        }\n+        _updateState(t);\n+        return null;\n+    }\n+\n+    int token = _xmlTokens.next();\n+\n+    // mostly copied from 'nextToken()'\n+    while (token == XmlTokenStream.XML_START_ELEMENT) {\n+        if (_mayBeLeaf) {\n+            _nextToken = JsonToken.FIELD_NAME;\n+            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n+            _currToken = JsonToken.START_OBJECT;\n+            return null;\n+        }\n+        if (_parsingContext.inArray()) {\n+            token = _xmlTokens.next();\n+            _mayBeLeaf = true;\n+            continue;\n+        }\n+        String name = _xmlTokens.getLocalName();\n+        _parsingContext.setCurrentName(name);\n+        if (_namesToWrap != null && _namesToWrap.contains(name)) {\n+            _xmlTokens.repeatStartElement();\n+        }\n+        _mayBeLeaf = true;\n+        _currToken = JsonToken.FIELD_NAME;\n+        return null;\n+    }\n+\n+    // Ok; beyond start element, what do we get?\n+    switch (token) {\n+    case XmlTokenStream.XML_END_ELEMENT:\n+        if (_mayBeLeaf) {\n+            // NOTE: this is different from nextToken() -- produce \"\", NOT null\n+            _mayBeLeaf = false;\n+            _currToken = JsonToken.VALUE_STRING;\n+            return (_currText = \"\");\n+        }\n+        _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n+        _parsingContext = _parsingContext.getParent();\n+        _namesToWrap = _parsingContext.getNamesToWrap();\n+        break;\n+    case XmlTokenStream.XML_ATTRIBUTE_NAME:\n+        // If there was a chance of leaf node, no more...\n+        if (_mayBeLeaf) {\n+            _mayBeLeaf = false;\n+            _nextToken = JsonToken.FIELD_NAME;\n+            _currText = _xmlTokens.getText();\n+            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n+            _currToken = JsonToken.START_OBJECT;\n+        } else {\n+            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n+            _currToken = JsonToken.FIELD_NAME;\n+        }\n+        break;\n+    case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n+        _currText = _xmlTokens.getText();\n+        _currToken = JsonToken.VALUE_STRING;\n+        return _currText;\n+    case XmlTokenStream.XML_TEXT:\n+        _currText = _xmlTokens.getText();\n+        if (_mayBeLeaf) {\n+            _mayBeLeaf = false;\n+            // Also: must skip following END_ELEMENT\n+            _xmlTokens.skipEndElement();\n+\n+            // NOTE: this is different from nextToken() -- NO work-around\n+            // for otherwise empty List/array\n+            _currToken = JsonToken.VALUE_STRING;\n+            return _currText;\n+        }\n+        // If not a leaf, need to transform into property...\n+        _parsingContext.setCurrentName(_cfgNameForTextElement);\n+        _nextToken = JsonToken.VALUE_STRING;\n+        _currToken = JsonToken.FIELD_NAME;\n+        break;\n+    case XmlTokenStream.XML_END:\n+        _currToken = null;\n+    }\n+    return null;\n+}",
            "file_path": "src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java",
            "method_name": "nextTextValue",
            "class_name": "FromXmlParser",
            "iteration": 1,
            "is_multi_method": false,
            "line_numbers": [
                601,
                602,
                603,
                604,
                605,
                606,
                607,
                608,
                609,
                610,
                611,
                612,
                613,
                614,
                615,
                616,
                617,
                618,
                619,
                620,
                621,
                622,
                623,
                624,
                625,
                626,
                627,
                628,
                629,
                630,
                631,
                632,
                633,
                634,
                635,
                636,
                637,
                638,
                639,
                640,
                641,
                642,
                643,
                644,
                645,
                646,
                647,
                648,
                649,
                650,
                651,
                652,
                653,
                654,
                655,
                656,
                657,
                658,
                659,
                660,
                661,
                662,
                663,
                664,
                665,
                666,
                667,
                668,
                669,
                670,
                671,
                672,
                673,
                674,
                675,
                676,
                677,
                678,
                679,
                680,
                681,
                682,
                683,
                684,
                685,
                686,
                687,
                688,
                689,
                690,
                691,
                692,
                693
            ]
        }
    ],
    "iterations": 1,
    "monitor_file": "traces/JacksonXml-3_trace.json"
}